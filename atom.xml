<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序媛学习之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://andchen.com/"/>
  <updated>2018-09-06T14:33:18.791Z</updated>
  <id>https://andchen.com/</id>
  
  <author>
    <name>Feng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python爬虫--Scrapy实战抓取新浪微博(14)</title>
    <link href="https://andchen.com/2018/09/06/Python/"/>
    <id>https://andchen.com/2018/09/06/Python/</id>
    <published>2018-09-06T12:31:13.000Z</published>
    <updated>2018-09-06T14:33:18.791Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲解了 Scrapy 的理论知识，接下来我们以一个反爬比较强的网站新浪微博为例，来实现一下 Scrapy 的大规模爬取。</p><h2 id="爬取思路"><a href="#爬取思路" class="headerlink" title="爬取思路"></a>爬取思路</h2><p>首先我们要实现用户的大规模爬取。这里采用的爬取方式是，以微博的几大V为起始点，爬取他们各自的粉丝和关注列表，然后获取粉丝和关注列表的粉丝和关注列表，以此类推，这样下去就可以实现递归爬取。如果一个用户与其他用户有社交网络上的联系，那他们的信息就会被爬取虫抓取到，这样我们就可以做到对所有用户的爬取。通过这种方式，我们可以得到用户的唯一ID，再根据ID获取每个用户发布的微博即可。</p><h2 id="爬取地址"><a href="#爬取地址" class="headerlink" title="爬取地址"></a>爬取地址</h2><p><a href="https://m.weibo.cn" target="_blank" rel="noopener">here</a></p><h2 id="爬取分析"><a href="#爬取分析" class="headerlink" title="爬取分析"></a>爬取分析</h2><p>我们打开开发者工具，切换到 XHR 过滤器，一直下拉关注列表，即可看到下方会出现很多 Ajax 请求，这些请求就是获取关注列表的 Ajax 请求，如下：</p><img src="/2018/09/06/Python/img1.jpg"><p>打开第一个 Ajax 请求，如下：</p><img src="/2018/09/06/Python/img2.jpg"><p>我们分析用户详情的 Ajax 链接，用户微博列表的 Ajax 链接，如下：</p><img src="/2018/09/06/Python/img3.jpg"><p>此处的 uid 和 page 分别代表用户 ID 和分页页码。</p><p>注意，这个 API可能随着时间的变化或者微博的改版而改变，以实测为准。</p><p>我们从几大 V 开始抓取，抓取他们的粉丝，关注列表，微博信息，然后递归抓取他们的粉丝和关注列表的粉丝，关注列表，微博信息，递归抓取，最后保存微博用户的基本信息，关注和粉丝列表，发布的微博。</p><p>我们选择 MongoDB 作为存储的数据库，可以更方便地存储用户的粉丝和关注列表。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>接下来，我们用 Scrapy 来实现这个抓取过程。首先创建一个项目，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject weibo</span><br></pre></td></tr></table></figure><p>进入项目中，新建一个 spider，名为 weibocn，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider weibocn m.weibo.cn</span><br></pre></td></tr></table></figure><p>我们首先修改 Spider，配置各个 Ajax 的 URL，选取几个大 V，将他们的 ID 赋值成一个列表，实现 start_requests() 方法，也就是依次抓取各个大 V de个人详情，然后 parse_user() 进行解析，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request, Spider</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiboSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'weibocn'</span></span><br><span class="line"></span><br><span class="line">    allowed_domains = [<span class="string">'m.weibo.cn'</span>]</span><br><span class="line">    <span class="comment"># 用户详情API</span></span><br><span class="line">    user_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;value=&#123;uid&#125;&amp;containerid=100505&#123;uid&#125;'</span></span><br><span class="line">    <span class="comment"># 关注列表API</span></span><br><span class="line">    follow_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_followers_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line">    <span class="comment"># 粉丝列表API</span></span><br><span class="line">    fan_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_fans_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line">    <span class="comment"># 微博列表API</span></span><br><span class="line">    weibo_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;page=&#123;page&#125;&amp;containerid=107603&#123;uid&#125;'</span></span><br><span class="line"></span><br><span class="line">    start_users = [<span class="string">'3217179555'</span>, <span class="string">'1742566624'</span>, <span class="string">'2282991915'</span>, <span class="string">'1288739185'</span>, <span class="string">'3952070245'</span>, <span class="string">'5878659096'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> uid <span class="keyword">in</span> self.start_users:</span><br><span class="line">            <span class="keyword">yield</span> Request(self.user_url.format(uid=uid), callback=self.parse_user)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_user</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        self.logger.debug(response)</span><br></pre></td></tr></table></figure><h3 id="创建Item"><a href="#创建Item" class="headerlink" title="创建Item"></a>创建Item</h3><p>我们解析用户的基本信息并生成 Item，这里我们先定义几个 Item，如用户，用户关系，微博的 Item，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    collection = <span class="string">'users'</span></span><br><span class="line"></span><br><span class="line">    id = Field()</span><br><span class="line">    name = Field()</span><br><span class="line">    avatar = Field()</span><br><span class="line">    cover = Field()</span><br><span class="line">    gender = Field()</span><br><span class="line">    description = Field()</span><br><span class="line">    fans_count = Field()</span><br><span class="line">    follows_count = Field()</span><br><span class="line">    weibos_count = Field()</span><br><span class="line">    verified = Field()</span><br><span class="line">    verified_reason = Field()</span><br><span class="line">    verified_type = Field()</span><br><span class="line">    follows = Field()</span><br><span class="line">    fans = Field()</span><br><span class="line">    crawled_at = Field()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRelationItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    collection = <span class="string">'users'</span></span><br><span class="line"></span><br><span class="line">    id = Field()</span><br><span class="line">    follows = Field()</span><br><span class="line">    fans = Field()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiboItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    collection = <span class="string">'weibos'</span></span><br><span class="line"></span><br><span class="line">    id = Field()</span><br><span class="line">    attitudes_count = Field()</span><br><span class="line">    comments_count = Field()</span><br><span class="line">    reposts_count = Field()</span><br><span class="line">    picture = Field()</span><br><span class="line">    pictures = Field()</span><br><span class="line">    source = Field()</span><br><span class="line">    text = Field()</span><br><span class="line">    raw_text = Field()</span><br><span class="line">    thumbnail = Field()</span><br><span class="line">    user = Field()</span><br><span class="line">    created_at = Field()</span><br><span class="line">    crawled_at = Field()</span><br></pre></td></tr></table></figure><h3 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h3><p>我们开始解析用户的基本信息，实现 parse_user()方法，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_user</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    解析用户信息</span></span><br><span class="line"><span class="string">    :param response: Response对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.logger.debug(response)</span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">'data'</span>).get(<span class="string">'userInfo'</span>):</span><br><span class="line">        user_info = result.get(<span class="string">'data'</span>).get(<span class="string">'userInfo'</span>)</span><br><span class="line">        user_item = UserItem()</span><br><span class="line">        field_map = &#123;</span><br><span class="line">            <span class="string">'id'</span>: <span class="string">'id'</span>, <span class="string">'name'</span>: <span class="string">'screen_name'</span>, <span class="string">'avatar'</span>: <span class="string">'profile_image_url'</span>, <span class="string">'cover'</span>: <span class="string">'cover_image_phone'</span>,</span><br><span class="line">            <span class="string">'gender'</span>: <span class="string">'gender'</span>, <span class="string">'description'</span>: <span class="string">'description'</span>, <span class="string">'fans_count'</span>: <span class="string">'followers_count'</span>,</span><br><span class="line">            <span class="string">'follows_count'</span>: <span class="string">'follow_count'</span>, <span class="string">'weibos_count'</span>: <span class="string">'statuses_count'</span>, <span class="string">'verified'</span>: <span class="string">'verified'</span>,</span><br><span class="line">            <span class="string">'verified_reason'</span>: <span class="string">'verified_reason'</span>, <span class="string">'verified_type'</span>: <span class="string">'verified_type'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> field, attr <span class="keyword">in</span> field_map.items():</span><br><span class="line">            user_item[field] = user_info.get(attr)</span><br><span class="line">        <span class="keyword">yield</span> user_item</span><br><span class="line">        <span class="comment"># 关注</span></span><br><span class="line">        uid = user_info.get(<span class="string">'id'</span>)</span><br><span class="line">        <span class="keyword">yield</span> Request(self.follow_url.format(uid=uid, page=<span class="number">1</span>), callback=self.parse_follows,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: <span class="number">1</span>, <span class="string">'uid'</span>: uid&#125;)</span><br><span class="line">        <span class="comment"># 粉丝</span></span><br><span class="line">        <span class="keyword">yield</span> Request(self.fan_url.format(uid=uid, page=<span class="number">1</span>), callback=self.parse_fans,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: <span class="number">1</span>, <span class="string">'uid'</span>: uid&#125;)</span><br><span class="line">        <span class="comment"># 微博</span></span><br><span class="line">        <span class="keyword">yield</span> Request(self.weibo_url.format(uid=uid, page=<span class="number">1</span>), callback=self.parse_weibos,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: <span class="number">1</span>, <span class="string">'uid'</span>: uid&#125;)</span><br></pre></td></tr></table></figure><p>我们还要保存用户的关注和粉丝列表。以关注列表为例，其解析方法为 parse_follows(),如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_follows</span><span class="params">(self, response)</span>:</span></span><br><span class="line">       <span class="string">"""</span></span><br><span class="line"><span class="string">       解析用户关注</span></span><br><span class="line"><span class="string">       :param response: Response对象</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       result = json.loads(response.text)</span><br><span class="line">       <span class="keyword">if</span> result.get(<span class="string">'ok'</span>) <span class="keyword">and</span> result.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>) <span class="keyword">and</span> len(result.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)) <span class="keyword">and</span> \</span><br><span class="line">               result.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)[<span class="number">-1</span>].get(</span><br><span class="line">                       <span class="string">'card_group'</span>):</span><br><span class="line">           <span class="comment"># 解析用户</span></span><br><span class="line">           follows = result.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)[<span class="number">-1</span>].get(<span class="string">'card_group'</span>)</span><br><span class="line">           <span class="keyword">for</span> follow <span class="keyword">in</span> follows:</span><br><span class="line">               <span class="keyword">if</span> follow.get(<span class="string">'user'</span>):</span><br><span class="line">                   uid = follow.get(<span class="string">'user'</span>).get(<span class="string">'id'</span>)</span><br><span class="line">                   <span class="keyword">yield</span> Request(self.user_url.format(uid=uid), callback=self.parse_user)</span><br><span class="line"></span><br><span class="line">           uid = response.meta.get(<span class="string">'uid'</span>)</span><br><span class="line">           <span class="comment"># 关注列表</span></span><br><span class="line">           user_relation_item = UserRelationItem()</span><br><span class="line">           follows = [&#123;<span class="string">'id'</span>: follow.get(<span class="string">'user'</span>).get(<span class="string">'id'</span>), <span class="string">'name'</span>: follow.get(<span class="string">'user'</span>).get(<span class="string">'screen_name'</span>)&#125; <span class="keyword">for</span> follow <span class="keyword">in</span></span><br><span class="line">                      follows]</span><br><span class="line">           user_relation_item[<span class="string">'id'</span>] = uid</span><br><span class="line">           user_relation_item[<span class="string">'follows'</span>] = follows</span><br><span class="line">           user_relation_item[<span class="string">'fans'</span>] = []</span><br><span class="line">           <span class="keyword">yield</span> user_relation_item</span><br><span class="line">           <span class="comment"># 下一页关注</span></span><br><span class="line">           page = response.meta.get(<span class="string">'page'</span>) + <span class="number">1</span></span><br><span class="line">           <span class="keyword">yield</span> Request(self.follow_url.format(uid=uid, page=page),</span><br><span class="line">                         callback=self.parse_follows, meta=&#123;<span class="string">'page'</span>: page, <span class="string">'uid'</span>: uid&#125;)</span><br></pre></td></tr></table></figure><p>抓取粉丝列表的原理和抓取关注列表原理相同，下面不再赘述。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>有些微博的时间可能不是标准的时间，这里我们需要统一转化这些时间，实现一个 parse_time()方法，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_time</span><span class="params">(self, date)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'刚刚'</span>, date):</span><br><span class="line">        date = time.strftime(<span class="string">'%Y-%m-%d %H:%M'</span>, time.localtime(time.time()))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'\d+分钟前'</span>, date):</span><br><span class="line">        minute = re.match(<span class="string">'(\d+)'</span>, date).group(<span class="number">1</span>)</span><br><span class="line">        date = time.strftime(<span class="string">'%Y-%m-%d %H:%M'</span>, time.localtime(time.time() - float(minute) * <span class="number">60</span>))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'\d+小时分钟前'</span>, date):</span><br><span class="line">        hour = re.match(<span class="string">'(\d+)'</span>, date).group(<span class="number">1</span>)</span><br><span class="line">        date = time.strftime(<span class="string">'%Y-%m-%d %H:%M'</span>, time.localtime(time.time() - float(hour) * <span class="number">60</span> * <span class="number">60</span>))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'昨天.*'</span>, date):</span><br><span class="line">        date = re.match(<span class="string">'昨天(.*)'</span>, date).group(<span class="number">1</span>).strip()</span><br><span class="line">        date = time.strftime(<span class="string">'%Y-%m-%d'</span>, time.localtime() - <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) + <span class="string">' '</span> + date</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'\d&#123;2&#125;-\d&#123;2&#125;'</span>, date):</span><br><span class="line">        date = time.strftime(<span class="string">'%Y-'</span>, time.localtime()) + date + <span class="string">' 00:00'</span></span><br><span class="line">    <span class="keyword">return</span> date</span><br></pre></td></tr></table></figure><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>数据清洗完毕之后，我们就要将数据保存到 MongoDB 数据库。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mongo_uri, mongo_db)</span>:</span></span><br><span class="line">        self.mongo_uri = mongo_uri</span><br><span class="line">        self.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>),</span><br><span class="line">            mongo_db=crawler.settings.get(<span class="string">'MONGO_DATABASE'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db = self.client[self.mongo_db]</span><br><span class="line">        self.db[UserItem.collection].create_index([(<span class="string">'id'</span>, pymongo.ASCENDING)])</span><br><span class="line">        self.db[WeiboItem.collection].create_index([(<span class="string">'id'</span>, pymongo.ASCENDING)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(item, UserItem) <span class="keyword">or</span> isinstance(item, WeiboItem):</span><br><span class="line">            self.db[item.collection].update(&#123;<span class="string">'id'</span>: item.get(<span class="string">'id'</span>)&#125;, &#123;<span class="string">'$set'</span>: item&#125;, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(item, UserRelationItem):</span><br><span class="line">            self.db[item.collection].update(</span><br><span class="line">                &#123;<span class="string">'id'</span>: item.get(<span class="string">'id'</span>)&#125;,</span><br><span class="line">                &#123;<span class="string">'$addToSet'</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">'follows'</span>: &#123;<span class="string">'$each'</span>: item[<span class="string">'follows'</span>]&#125;,</span><br><span class="line">                        <span class="string">'fans'</span>: &#123;<span class="string">'$each'</span>: item[<span class="string">'fans'</span>]&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="Cookies-池对接"><a href="#Cookies-池对接" class="headerlink" title="Cookies 池对接"></a>Cookies 池对接</h3><p>新浪微博的反爬能力非常强，我们需要做一些防范反爬取的措施才可以顺利完成数据爬取。</p><p>我们本地启动 Cookies 池，实现一个 Middleware，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CookiesMiddleware</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cookies_url)</span>:</span></span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.cookies_url = cookies_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_cookies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(self.cookies_url)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                cookies = json.loads(response.text)</span><br><span class="line">                <span class="keyword">return</span> cookies</span><br><span class="line">        <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        self.logger.debug(<span class="string">'正在获取Cookies'</span>)</span><br><span class="line">        cookies = self.get_random_cookies()</span><br><span class="line">        <span class="keyword">if</span> cookies:</span><br><span class="line">            request.cookies = cookies</span><br><span class="line">            self.logger.debug(<span class="string">'使用Cookies '</span> + json.dumps(cookies))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        settings = crawler.settings</span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            cookies_url=settings.get(<span class="string">'COOKIES_URL'</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="代理池对接"><a href="#代理池对接" class="headerlink" title="代理池对接"></a>代理池对接</h3><p>微博还有一个反爬措施就是，检测到同一 IP 请求量过大时就会出现414状态吗，如果遇到这样的的情况可以切换代理。例如，在本地5555端口运行，获取随机可用代理的地址为： <a href="http：//localhost:5555/random">here</a> ,访问这个接口即可获取一个随机可用代理，实现一个 Middleware，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMiddleware</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proxy_url)</span>:</span></span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.proxy_url = proxy_url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_proxy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(self.proxy_url)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                proxy = response.text</span><br><span class="line">                <span class="keyword">return</span> proxy</span><br><span class="line">        <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.meta.get(<span class="string">'retry_times'</span>):</span><br><span class="line">            proxy = self.get_random_proxy()</span><br><span class="line">            <span class="keyword">if</span> proxy:</span><br><span class="line">                uri = <span class="string">'https://&#123;proxy&#125;'</span>.format(proxy=proxy)</span><br><span class="line">                self.logger.debug(<span class="string">'使用代理 '</span> + proxy)</span><br><span class="line">                request.meta[<span class="string">'proxy'</span>] = uri</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        settings = crawler.settings</span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            proxy_url=settings.get(<span class="string">'PROXY_URL'</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="启动Middleware"><a href="#启动Middleware" class="headerlink" title="启动Middleware"></a>启动Middleware</h3><p>我们在配置文件中启用这两个 Middleware，修改 settings.py,如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">'weibo.middlewares.CookiesMiddleware'</span>: <span class="number">544</span>,</span><br><span class="line">    <span class="string">'weibo.middlewares.ProxyMiddleware'</span>: <span class="number">555</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>到此为止，整个微博爬虫就实现完毕了，我们运行如下命令启动爬虫：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl weibocn</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/Andchenn/WeiboScrapy" target="_blank" rel="noopener">here</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面讲解了 Scrapy 的理论知识，接下来我们以一个反爬比较强的网站新浪微博为例，来实现一下 Scrapy 的大规模爬取。&lt;/p&gt;
&lt;h2 id=&quot;爬取思路&quot;&gt;&lt;a href=&quot;#爬取思路&quot; class=&quot;headerlink&quot; title=&quot;爬取思路&quot;&gt;&lt;/a&gt;爬取思路
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--Scrapy组件的用法(13)</title>
    <link href="https://andchen.com/2018/08/20/Python/"/>
    <id>https://andchen.com/2018/08/20/Python/</id>
    <published>2018-08-20T13:28:37.000Z</published>
    <updated>2018-09-06T12:40:01.059Z</updated>
    
    <content type="html"><![CDATA[<p>通过上一篇文章，我相信大家对于 Scrapy 的使用也有了初步的了解。如果说要使用 Scrapy 写一些爬虫，也并非什么难事了。那么为了能写出更加复杂的爬虫，我们在本篇文章就来了解一下 Scrapy 的组件及他们的用法。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Scrapy 作为一个框架，整体的组件协作我们还是要做到流程清晰的。我们来看一下经典的 Scrapy 架构图：</p><img src="/2018/08/20/Python/img1.jpg"><p>我们上一篇文章写的 Scrapy 项目大致流程就是：</p><p>确定爬虫名称和要抓取的初始网站;</p><p>请求网站获得响应数据 Respond ;</p><p>解析 Respond 提取数据;</p><p>有需要跟进的url 继续循环执行第二步;</p><p>将需要的数据通过管道 Pipeline 的处理;</p><p>处理完的数据传给 Item 保存。</p><p>图中的 Scrapy Engine 就是 Scrapy 的引擎，他处于中间位置，主要负责各个组件之间的通信，数据传递。</p><p>那上图的 Spiders 就是来完成爬虫的逻辑，还有网页数据的提取。他将要请求的 url 通过 Scrapy Engine 引擎，传给 Scheduler（调度器）。</p><p>调度器接收了引擎发送来的 Requests 请求，按顺序排列整理。</p><p>由于所有的数据交流都是要通过引擎的，所以调度器是通过把处理好的 Requests 有发送给引擎，由引擎通过 Downloader Middlewares（下载中间件）发送给  Downloader（下载器）。</p><p>下载器通过下载中间件的设置来下载引擎传过来的Requests 的 url，并且将获取到的 Response 又发送给引擎（如果有下载失败的 Requests，那么下载器会在后面接着下载）。</p><p>引擎收到 Response 后，再将它发送给 Spiders，Spiders 对 Response 解析提取出需要的数据（或者还有需要继续请求的 url，会继续执行上面的循环）。</p><p>Spiders 将这些数据发送给引擎，最后引擎将这些数据发送给 Item Pipeline 进行数据处理和存储。</p><p>那么这个流程就结束了。下面我给大家吧相应组件还有 Scrapy 提供的命令行工具的文档地址整理给大家。</p><h3 id="Spiders"><a href="#Spiders" class="headerlink" title="Spiders"></a>Spiders</h3><p>我们上篇文章有用过 Spider，就是我们爬虫类的基类。Spider 它主要就是来完成爬虫的逻辑，还有网页数据的提取。它将要请求的 url 通过 Scrapy Engine 引擎，传给 Scheduler (调度器)，</p><p>对 spider 来说，爬取的循环类似下文：</p><p>以初始化 Request，并设置回调函数。当该 request 下载完毕并返回时，将生成response，并作为参数传给该回调函数。</p><p>spider 中初始的 request 是通过调用 是 start_requests()来获取的。 start_requests()读取 start_urls 中的 URL，并以 parse 为回调函数生成 Request。</p><p>在回调函数内分析返回的(网页)内容，返回 Item 对象或者 Request 或者一个包括二者的可迭代容器。返回的 Request 对象之后会经过 Scrapy 处理，下载相应的内容，并调用设置的 callback 函数(函数可相同)<br>。</p><p>在回调函数内，您可以使用 选择器(Selectors) (您也可以使用BeautifulSoup, lxml 或者您想用的任何解析器) 来分析网页内容，并根据分析的数据生成item。</p><p>最后，由spider返回的item将被存到数据库(由某些 Item Pipeline 处理)或使用 Feed exports 存入到文件中。</p><h3 id="Item-Pipeline"><a href="#Item-Pipeline" class="headerlink" title="Item Pipeline"></a>Item Pipeline</h3><p>文档地址：<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#id1" target="_blank" rel="noopener">this</a></p><h3 id="Downloader-Middleware"><a href="#Downloader-Middleware" class="headerlink" title="Downloader Middleware"></a>Downloader Middleware</h3><p>文档地址：<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/downloader-middleware.html#downloader-middleware" target="_blank" rel="noopener">this</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Scrapy 功能非常强大，爬取效率高，相关扩展组件多，可配置和可扩展程度非常高，希望大家能学好它。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过上一篇文章，我相信大家对于 Scrapy 的使用也有了初步的了解。如果说要使用 Scrapy 写一些爬虫，也并非什么难事了。那么为了能写出更加复杂的爬虫，我们在本篇文章就来了解一下 Scrapy 的组件及他们的用法。&lt;/p&gt;
&lt;h3 id=&quot;理解&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--使用Scrapy框架写的小项目(12)</title>
    <link href="https://andchen.com/2018/08/13/Python/"/>
    <id>https://andchen.com/2018/08/13/Python/</id>
    <published>2018-08-13T05:39:19.000Z</published>
    <updated>2018-08-13T07:22:32.879Z</updated>
    
    <content type="html"><![CDATA[<p>这章我来用一个小项目来实现上一章的所说的 Scrapy 框架的基本用法，完胜一遍 Scrapy 抓取流程，从而我们可以对 Scrapy 的基本用法更了解。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>我们需要安装好 Scrapy 框架、MongoDB 和 PyMongo 库。具体安装自己搜索。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建一个 Scrapy 项目，项目文件可以直接用 scrapy 命令生成，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject tutorial</span><br></pre></td></tr></table></figure><h3 id="创建Spider"><a href="#创建Spider" class="headerlink" title="创建Spider"></a>创建Spider</h3><p>Spider 是自己定义的类，Scrapy 用它来从网页里抓取内容，并解析抓取的结果。不过这个类必须继承 Scrapy 提供的 Spider 类 scrapy.Spider，还要定义 Spider 的名称和起始请求，以及怎么处理怕去后的结果的方法。</p><p>使用命令行创建一个 Spider，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd tutor</span><br><span class="line">scrapy genspider quotes quotes.toscrape.com</span><br></pre></td></tr></table></figure><p>执行完毕后，进入 spider 文件夹多了 quotes.py，它是刚刚创建的，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'quotes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'quotes.toscrape.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="开始代码"><a href="#开始代码" class="headerlink" title="开始代码"></a>开始代码</h3><p>Item 是保存爬取数据的容器，它的使用方法和字典类似。不过，相比 Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。</p><p>创建 Item 需要继承 scrapy.Item 类，并且定义类型为 scrapy.Field 的字段。观察目标网站，我们可以获取到的内容有 text、author、tags。修改 item.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    text = scrapy.Field()</span><br><span class="line">    author = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br></pre></td></tr></table></figure><img src="/2018/08/13/Python/img1.jpg"><p>看图，接着编写 spider.py 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> tutor.items <span class="keyword">import</span> TutorItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'quotes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'quotes.toscrape.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> quotes:</span><br><span class="line">            item = TutorItem()</span><br><span class="line">            item[<span class="string">'text'</span>] = quote.css(<span class="string">'.text::text'</span>).extract.first()</span><br><span class="line">            item[<span class="string">'author'</span>] = quote.css(<span class="string">'.author::text'</span>).extract.first()</span><br><span class="line">            item[<span class="string">'tags'</span>] = quote.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>接下来，为了清洗 HTML 数据，验证爬取数据，检查爬取字段。查重并丢弃重复内容，将爬取结果保存到数据库。修改 pipeline.py，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mongo_uri, mongo_db)</span>:</span></span><br><span class="line">        self.mongo_uri = mongo_uri</span><br><span class="line">        self.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>),</span><br><span class="line">            mongo_db=crawler.settings.get(<span class="string">'MONGO_DB'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db = self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        name = item.__class__.__name__</span><br><span class="line">        self.db[name].insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br></pre></td></tr></table></figure><p>最后，我们在 settings.py 中加入如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'tutor.pipelines.TextPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'tutor.pipelines.MongoPipeline'</span>: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br><span class="line">MONGO_URI = <span class="string">'localhost'</span></span><br><span class="line">MONGO_DB = <span class="string">'tutor'</span></span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/Andchenn/tutor" target="_blank" rel="noopener">here</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这章我来用一个小项目来实现上一章的所说的 Scrapy 框架的基本用法，完胜一遍 Scrapy 抓取流程，从而我们可以对 Scrapy 的基本用法更了解。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--Scrapy框架的安装和基本使用(11)</title>
    <link href="https://andchen.com/2018/08/04/Python/"/>
    <id>https://andchen.com/2018/08/04/Python/</id>
    <published>2018-08-04T02:29:51.000Z</published>
    <updated>2018-08-04T05:36:56.052Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，之前大概学习了一下 Beautiful Soup 进行简单数据爬取的流程，但是那只是适用于一些简单的数据量比较小的爬虫项目，如果需要爬取的数据量比较大的话，之前上的方法必定非常缓慢，所以就有了 Scrapy， Scrapy 是一个快速的 web 抓取框架，可抓取 web 站点并从页面中提取结构化的数据。Scrapy 给我们提供了许多的爬虫基类，我们可以直接继承使用，当然，既然 Scrapy 是一个框架，我们也可以根据自己的需要对它进行修改，下面我们先来看看他的安装。</p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo python3 -m pip install Scrapy</span><br></pre></td></tr></table></figure><h2 id="Scrapy的基本使用"><a href="#Scrapy的基本使用" class="headerlink" title="Scrapy的基本使用"></a>Scrapy的基本使用</h2><p>Scrapy 的中文文档地址：<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/overview.html" target="_blank" rel="noopener">here</a></p><p>它的基本项目流程为：</p><p>创建一个 Scrapy 项目</p><p>定义提取的 Item</p><p>编写爬取网站的 spider 并提取 Item</p><p>编写 Item Pipeline 来存储取到的 Item (即数据)</p><p>而一般我们的爬虫流程为:</p><p>爬取索引页面:请求索引页的 URL 并得到源代码，进行下一步分析;</p><p>获得内容和下一步链接：分析源代码，提取索引页数据，并且获取下一页链接，进行下一步爬取;</p><p>翻页爬取：请求下一页信息，分析内容并请求在下一链接;</p><p>保存爬取结果：将爬取结果保存为特定格式和文本，或者保存数据库。</p><p>下面我们一步步看看如何使用。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在开始爬取之前，你必须创建一个新的 Scrapy 项目。进入你打算存储代码的目录中，运行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject zhihuTest</span><br></pre></td></tr></table></figure><p>该命令将会创建包含下列内容的 scrapyTest 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── scrapy.cfg</span><br><span class="line">└── zhihuTest</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── items.py</span><br><span class="line">    ├── middlewares.py</span><br><span class="line">    ├── pipelines.py</span><br><span class="line">    ├── __pycache__</span><br><span class="line">    ├── settings.py</span><br><span class="line">    └── spiders</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── __pycache__</span><br></pre></td></tr></table></figure><p>这些文件分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scrapy.cfg：项目的配置文件</span><br><span class="line">zhihuTest/：该项目的 python 模块。之后你将在此加入代码。</span><br><span class="line">zhihuTest/items.py：项目中的 item 文件。</span><br><span class="line">zhihuTest/pipelines.py：项目中的 pipelines 文件。</span><br><span class="line">zhihuTest/settings.py：项目的设置文件。</span><br><span class="line">zhihuTest/spiders/：放置 spider 代码的目录。</span><br></pre></td></tr></table></figure><h3 id="定义-Item"><a href="#定义-Item" class="headerlink" title="定义 Item"></a>定义 Item</h3><p>该一步是定义我们需要获取到的数据信息，比如我们需要获取网站里的一些 url，网站文章的内容，文章的作者等。这一步定义的地方就在我们的 items.py 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">zhihuItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    article = scrapy.Field()</span><br></pre></td></tr></table></figure><h3 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a>编写Spider</h3><p>这一步就是写我们最熟悉的爬虫了，而我们的 Scrapy 框架可以让我们不需要去考虑实现的方法，只需要写出爬取的逻辑就可以了。</p><p>首先我们需要在 spiders/ 文件夹下创建我们的爬虫文件，比如就叫spider.py。写爬虫前，我们需要先定义一些内容。我们以知乎日报为例：<a href="https://daily.zhihu.com/" target="_blank" rel="noopener">here</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Spider</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"zhihu"</span></span><br><span class="line">    allowed_domains = [<span class="string">"zhihu.com"</span>]</span><br><span class="line">    start_urls = [<span class="string">'https://daily.zhihu.com/'</span>]</span><br></pre></td></tr></table></figure><p>然后我们定义一个解析函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    print(response.text)</span><br></pre></td></tr></table></figure><p>我们直接打印一下，看看这个解析函数是什么。</p><h3 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl zhihuTest</span><br></pre></td></tr></table></figure><p>由于Scrapy是不支持在IDE中执行，所以我们必须在命令行里执行命令，我们要确定是不是cd到爬虫目录下。然后执行，这里的命令顾名思义，crawl是蜘蛛的意思，zhihu就是我们定义的爬虫名称了。</p><p>查看输出，我们先看到的是一些爬虫类的输出，可以看到输出的log中包含定义在 start_urls 的初始URL，并且与spider中是一一对应的。我们接着可以看到打印出了网页源代码。可是我们似乎并没有做什么，就得到了网页的源码，这是Scrapy比较方便的一点。</p><h3 id="保存爬取到的数据"><a href="#保存爬取到的数据" class="headerlink" title="保存爬取到的数据"></a>保存爬取到的数据</h3><p>这里我们需要在管道文件 pipelines.py 里去操作数据，比如我们要将这些数据的文章标题只保留5个字，然后保存在文本里。或者我们要将数据保存到数据库里，这些都是在管道文件操作。我们后面在详细讲解。</p><p>那么最简单的存储方法是使用命令行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl zhihuTest -o items.json</span><br></pre></td></tr></table></figure><p>这条命令就会完成我们的数据保存在根目录的 json 文件里，我们还可以将它格式保存为 msv，pickle 等。改变命令后面的格式就可以了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇教程仅介绍了Scrapy的基础，还有更精彩的内容在后面，下篇在讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，之前大概学习了一下 Beautiful Soup 进行简单数据爬取的流程，但是那只是适用于一些简单的数据量比较小的爬虫项目，如果需要爬取的数据量比较大的话，之前上的方法必定非常缓慢，所以就有了 Scrapy， Scrapy 是一个快速的 web 抓取框架，可抓取 w
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--Cookie介绍和模拟登录(10)</title>
    <link href="https://andchen.com/2018/07/29/Python/"/>
    <id>https://andchen.com/2018/07/29/Python/</id>
    <published>2018-07-28T16:42:50.000Z</published>
    <updated>2018-07-28T18:04:29.731Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，这篇文章我们来看一下Cookie是什么，和他的一些用法。</p><h2 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie?"></a>什么是Cookie?</h2><p>在实际情况中，很多网站的内容都是需要登录之后才能看到，如此我们就需要进行模拟登录，使用登录后的状态进行爬取。这里就需要使用到Cookie。</p><p>现在大多数的网站都是使用Cookie跟踪用户的登录状态，一旦网站验证了登录信息，就会将登录信息保存在浏览器的cookie中。网站会把这个cookie作为验证的凭据，在浏览网站的页面是返回给服务器。<br>因为cookie是保存在本地的，自然cookie就可以进行篡改和伪造，暂且不表，我们先来看看Cookie长什么样子。</p><p>我们以豆瓣为例。打开Chrome的开发者工具(F12)，点开Network，打开一个链接，在headers里面：</p><p>未登陆 Cookie</p><img src="/2018/07/29/Python/img1.jpg"><p>我们复制出来看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bid=MJr42Sj_6JM; gr_user_id=0a379acd-54a1-4527-90d3-176f3d56e0a3; __utmc=30149280; viewed="6025284_25909353"; _vwo_uuid_v2=D9A9DDF9129C67D489D9AB470C1E3071C|8d76f7c9fe740c712105c48d2bf28c29; ll="118295"; ps=y; push_noty_num=0; push_doumail_num=0; _pk_ref.100001.a7dd=%5B%22%22%2C%22%22%2C1532796597%2C%22https%3A%2F%2Fwww.google.com%2F%22%5D; _pk_ses.100001.a7dd=*; _ga=GA1.3.869379282.1526733191; _gid=GA1.3.667268441.1532796597; page_style="mobile"; __utma=30149280.869379282.1526733191.1531998990.1532796991.14; __utmz=30149280.1532796991.14.5.utmcsr=accounts.douban.com|utmccn=(referral)|utmcmd=referral|utmcct=/register_success; __utmt=1; __utmv=30149280.18191; douban-profile-remind=1; __utmb=30149280.10.10.1532796991; _gat=1; _pk_id.100001.a7dd=c18e4a033368c413.1532796597.1.1532797319.1532796597.; refer_url=https://read.douban.com/ebook/48673120/?icn=index-indie-rec</span><br></pre></td></tr></table></figure><p>由一个个键值对组成。</p><p>接下来，我们以<a href="https://read.douban.com" target="_blank" rel="noopener">豆瓣</a>的一本书籍的详情页为例，讲解一下Cookie的使用。</p><p>豆瓣是一个电子书下载网站，<a href="https://read.douban.com" target="_blank" rel="noopener">地址</a></p><p>正常情况下，未登录用户是看不到下载链接的，如下：</p><p>登陆后 Cookie</p><img src="/2018/07/29/Python/img2.jpg"><p>通过未登录和登录的 Cookie 对比，是不是有所领悟了，接着说说它的用途，然后进行模拟登录演示。</p><h2 id="Cookie的用途"><a href="#Cookie的用途" class="headerlink" title="Cookie的用途"></a>Cookie的用途</h2><p>(1) 存储用户登录信息，判断用户是否登录；</p><p>(2) 保存用户浏览足迹；</p><p>Cookie是服务器在客户端存储的信息。这些信息是有服务器生成服务器解释的。</p><p>请求时，客户端需要把未超时的Cookies发送给服务器。服务器需要解析Cookies判断用户信息。</p><p>我们的浏览器会在你每次浏览网页是自动存储cookie，比如你打开清除浏览器浏览记录时，就会有cookie信息。</p><p>cookie给我们带来了很多便利，他还可以记录我们的浏览足迹，停留页面时间。比如你狂淘宝的时候，淘宝的推荐你喜欢的宝贝，就是根据你的cookie，获取你浏览过哪些商品，而生成的。</p><h2 id="模拟登录演示"><a href="#模拟登录演示" class="headerlink" title="模拟登录演示"></a>模拟登录演示</h2><p>我们还是以豆瓣为例。<a href="https://read.douban.com/ebook/54232695/" target="_blank" rel="noopener">演示网址</a> ，这个URL是我的豆瓣信息页，当然大家可以使用自己的豆瓣页做例子。如果我们直接访问它，会看到上方的登录按钮，而是我已经登录了在访问呢。就不会显示登录按钮，而是个人编辑资料一些链接。</p><p>那么，如果我们使用爬虫去访问呢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">' Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Mobile Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://read.douban.com/ebook/54232695/'</span></span><br><span class="line">r = requests.get(url, headers=headers).text</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>通过打印的结果，我们可以看到，html 代码里是有登录按钮的。这就证明我们并没有登录这个页面。那么，如果我们在爬取一些需要登录账号才可以爬取数据的网站时，我们必然是要解决登录问题的。那么如何实现登录呢。</p><p>答案就是我们的Cookie了。我们在之前的文章中说过，requests库在处理Cookie时，是非常简单的。我们只需要向添加‘User-Agent’一样添加请求cookies就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="comment"># 你登录过后的浏览器cookies,</span></span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Mobile Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://read.douban.com/ebook/54232695/'</span></span><br><span class="line">r = requests.get(url, headers=headers).text</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>我们再次看打印信息，就可以看到有编辑个人资料的链接了。这就说明我们已经成功登录了。看！是不是很简单呢，淡定，难的在后面呢。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>那么，如果我们要登录一些复杂的网站，比如新浪微博这种必须要登录才能获取信息的网站，使用cookie登录是肯定行不通的。因为这些网站会经常更新一些网站的算法，我们的 cookie 就会在工作一会失效，那么这些网站我们就需要向登录页 post 我们的登录信息。</p><p>这些登录信息参数一般都会存放在登录页的请求头下面的 Form Data 里面，我们只要携带这些信息 Post，就可以顺利登录。但是如果遇到验证码，那么就很麻烦了。验证码的问题一直是考验爬虫的一个门槛，这个大家自己研究。<br>获取我后面会讲。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，这篇文章我们来看一下Cookie是什么，和他的一些用法。&lt;/p&gt;
&lt;h2 id=&quot;什么是Cookie&quot;&gt;&lt;a href=&quot;#什么是Cookie&quot; class=&quot;headerlink&quot; title=&quot;什么是Cookie?&quot;&gt;&lt;/a&gt;什么是Cookie?&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--使用Selenium爬取淘宝商品(9)</title>
    <link href="https://andchen.com/2018/07/27/Python-1/"/>
    <id>https://andchen.com/2018/07/27/Python-1/</id>
    <published>2018-07-27T14:15:51.000Z</published>
    <updated>2018-07-27T15:11:08.527Z</updated>
    
    <content type="html"><![CDATA[<p>在前两章中，我们已经成功尝试分析Ajax来抓取相关数据，但是并不是所有页面都可以通过分析Ajax来完成抓取。比如，淘宝，它的整个页面数据确实也是通过Ajax获取的，但是这些Ajax接口参数比较复杂，可能会包含加密密钥等，所以如果想自己构造Ajax参数，还是比较困难的。对于这种页面，最方便快捷的抓取方法就是通过Selenium。本章中，我们就用Selenium来模拟浏览器操作，抓取淘宝的商品信息，并将结果保存到MongoDB。</p><p>上一章中，我已经陈述了 Selenium 的基本操作了，里面也有相关驱动 ChromeDriver 的安装，这里就不再赘述了。</p><h2 id="页面分析"><a href="#页面分析" class="headerlink" title="页面分析"></a>页面分析</h2><p>本章的目标是爬取商品信息。下图是一个商品条目，其中包含商品的基本信息，包括商品图片、名称、价格、购买人数、店铺名称和店铺所在地，我们要做的就是将这些信息都抓取下来。</p><img src="/2018/07/27/Python-1/img1.jpg"><p>抓取入口就是淘宝的搜索页面，这个链接可以通过直接构造参数访问。例如，如果搜索iPad，就可以直接访问<a href="https://s.taobao.com/search?q=iPad" target="_blank" rel="noopener">地址</a>，呈现的就是第一页的搜索结果，如下：</p><img src="/2018/07/27/Python-1/img2.jpg"><p>在页面下方，有一个分页导航，其中既包括前5页的链接，也包括下一页的链接，同时还有一个输入任意页码跳转的链接，如下：</p><img src="/2018/07/27/Python-1/img3.jpg"><p>这里商品的搜索结果一般最大都为100页，要获取每一页的内容，只需要将页码从1到100顺序遍历即可，页码数是确定的。所以，直接在页面跳转文本框中输入要跳转的页码，然后点击“确定”按钮即可跳转到页码对应的页面。</p><p>这里不直接点击“下一页”的原因是：一旦爬取过程中出现异常退出，比如到50页退出了，此时点击“下一页”时，就无法快速切换到对应的后续页面了。此外，在爬取过程中，也需要记录当前的页码数，而且一旦点击“下一页”之后页面加载失败，还需要做异常检测，检测当前页面是加载到了第几页。整个流程相对比较复杂，所以这里我们直接用跳转的方式来爬取页面。</p><p>当我们成功加载出某一页商品列表时，利用Selenium即可获取页面源代码，然后再用相应的解析库解析即可。这里我们选用pyquery进行解析。下面我们用代码来实现整个抓取过程。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="获取商品列表"><a href="#获取商品列表" class="headerlink" title="获取商品列表"></a>获取商品列表</h3><p>首先，需要构造一个抓取的URL：<a href="https://s.taobao.com/search?q=iPad" target="_blank" rel="noopener">地址</a>。这个URL非常简洁，参数q就是要搜索的关键字。只要改变这个参数，即可获取不同商品的列表。这里我们将商品的关键字定义成一个变量，然后构造出这样的一个URL。然后，就需要用Selenium进行抓取了。我们实现如下抓取列表页的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">KEYWORD = <span class="string">'iPad'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    抓取索引页</span></span><br><span class="line"><span class="string">    :param page: 页码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">'正在爬取第'</span>, page, <span class="string">'页'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">'https://s.taobao.com/search?q='</span> + quote(KEYWORD)</span><br><span class="line">        browser.get(url)</span><br><span class="line">        <span class="keyword">if</span> page &gt; <span class="number">1</span>:</span><br><span class="line">            input = wait.until(</span><br><span class="line">                EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager div.form &gt; input'</span>)))</span><br><span class="line">            submit = wait.until(</span><br><span class="line">                EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager div.form &gt; span.btn.J_Submit'</span>)))</span><br><span class="line">            input.clear()</span><br><span class="line">            input.send_keys(page)</span><br><span class="line">            submit.click()</span><br><span class="line">        wait.until(</span><br><span class="line">            EC.text_to_be_present_in_element((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager li.item.active &gt; span'</span>), str(page)))</span><br><span class="line">        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'.m-itemlist .items .item'</span>)))</span><br><span class="line">        get_products()</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        index_page(page)</span><br></pre></td></tr></table></figure><h3 id="解析商品列表"><a href="#解析商品列表" class="headerlink" title="解析商品列表"></a>解析商品列表</h3><p>接下来，我们就可以实现get_products()方法来解析商品列表了。这里我们直接获取页面源代码，然后用pyquery进行解析，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_products</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    提取商品数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    html = browser.page_source</span><br><span class="line">    doc = pq(html)</span><br><span class="line">    items = doc(<span class="string">'#mainsrp-itemlist .items .item'</span>).items()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        product = &#123;</span><br><span class="line">            <span class="string">'image'</span>: item.find(<span class="string">'.pic .img'</span>).attr(<span class="string">'data-src'</span>),</span><br><span class="line">            <span class="string">'price'</span>: item.find(<span class="string">'.price'</span>).text(),</span><br><span class="line">            <span class="string">'deal'</span>: item.find(<span class="string">'.deal-cnt'</span>).text(),</span><br><span class="line">            <span class="string">'title'</span>: item.find(<span class="string">'.title'</span>).text(),</span><br><span class="line">            <span class="string">'shop'</span>: item.find(<span class="string">'.shop'</span>).text(),</span><br><span class="line">            <span class="string">'location'</span>: item.find(<span class="string">'.location'</span>).text()</span><br><span class="line">        &#125;</span><br><span class="line">        print(product)</span><br><span class="line">        save_to_mongo(product)</span><br></pre></td></tr></table></figure><h3 id="保存到MongoDB"><a href="#保存到MongoDB" class="headerlink" title="保存到MongoDB"></a>保存到MongoDB</h3><p>接下来，我们将商品信息保存到MongoDB，实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MONGO_URL = <span class="string">'localhost'</span></span><br><span class="line">MONGO_DB = <span class="string">'taobao'</span></span><br><span class="line">MONGO_COLLECTION = <span class="string">'products'</span></span><br><span class="line">client = pymongo.MongoClient(MONGO_URL)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    保存至MongoDB</span></span><br><span class="line"><span class="string">    :param result: 结果</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> db[MONGO_COLLECTION].insert(result):</span><br><span class="line">            print(<span class="string">'存储到MongoDB成功'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">'存储到MongoDB失败'</span>)</span><br></pre></td></tr></table></figure><h3 id="遍历每页"><a href="#遍历每页" class="headerlink" title="遍历每页"></a>遍历每页</h3><p>刚才我们所定义的 get_index() 方法需要接受参数 page，page 代码页码。这里我们实现页码遍历即可，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MAX_PAGE = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历每一页</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, MAX_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_page(i)</span><br></pre></td></tr></table></figure><p>这样我们的淘宝商品爬虫就完成了，最后调用main()方法即可运行。</p><h3 id="Chrome-Headless模式"><a href="#Chrome-Headless模式" class="headerlink" title="Chrome Headless模式"></a>Chrome Headless模式</h3><p>启用Headless模式的方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument('--headless')</span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/Andchenn/TaoBaoItem" target="_blank" rel="noopener">here</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>通过这个项目，我们用Selenium演示了淘宝页面的抓取。利用它，我们不用去分析Ajax请求，真正做到可见即可爬。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前两章中，我们已经成功尝试分析Ajax来抓取相关数据，但是并不是所有页面都可以通过分析Ajax来完成抓取。比如，淘宝，它的整个页面数据确实也是通过Ajax获取的，但是这些Ajax接口参数比较复杂，可能会包含加密密钥等，所以如果想自己构造Ajax参数，还是比较困难的。对于这
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--Selenium基本操作(8)</title>
    <link href="https://andchen.com/2018/07/27/Python/"/>
    <id>https://andchen.com/2018/07/27/Python/</id>
    <published>2018-07-27T01:14:27.000Z</published>
    <updated>2018-07-27T14:15:51.589Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，这篇文章我们来看一下 Selenium 库结合、Chrome，Firefox，Edge 等一些浏览器的操作。本章中，就让我们来感受一下它的强大之处吧。</p><h2 id="什么是Selenium"><a href="#什么是Selenium" class="headerlink" title="什么是Selenium"></a>什么是Selenium</h2><p>Selenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些JavaScript动态渲染的页面来说，此种抓取方式非常有效。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>pip直接安装Selenium库：pip install selenium</p><p>浏览器驱动的安装：</p><p>Chrome 浏览器驱动：<a href="https://sites.google.com/a/chromium.org/chromedriver" target="_blank" rel="noopener">地址</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>准备工作做好后，首先来大体看一下 Selenium 有一些怎样的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    input = browser.find_element_by_id(<span class="string">'kw'</span>)</span><br><span class="line">    input.send_keys(<span class="string">'Python'</span>)</span><br><span class="line">    input.send_keys(Keys.ENTER)</span><br><span class="line">    wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID, <span class="string">'content_left'</span>)))</span><br><span class="line">    print(browser.current_url)</span><br><span class="line">    print(browser.get_cookies())</span><br><span class="line">    print(browser.page_source)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><p>运行代码后发现，会自动弹出一个Chrome浏览器。浏览器首先会跳转到百度，然后在搜索框中输入Python，接着跳转到搜索结果页，搜索结果加载出来后，控制台分别会输出当前的URL、当前的Cookies和网页源代码。</p><p>所以说，如果用Selenium来驱动浏览器加载网页的话，就可以直接拿到JavaScript渲染的结果了，不用担心使用的是什么加密系统。</p><p>下面来详细了解一下 Selenium 的用法。</p><h2 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h2><p>Selenium支持非常多的浏览器，如Chrome、Firefox、Edge等，还有Android、BlackBerry等手机端的浏览器。另外，也支持无界面浏览器PhantomJS。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure><p>这样就完成了浏览器对象的初始化并将其赋值为browser对象。接下来，我们要做的就是调用browser对象，让其执行各个动作以模拟浏览器操作。</p><h2 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>我们将要访问的url传给get方法。调用浏览器访问url。</p><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)</span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">print(input_first, input_second, input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>这里我们使用3种方式获取输入框，分别是根据ID、CSS选择器和XPath获取，它们返回的结果是完全一致的。</p><p>这里列出所有获取单个节点的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br></pre></td></tr></table></figure><h3 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>也就是说，如果我们用find_element()方法，只能获取匹配的第一个节点。如果用find_elements()方法，则结果是列表类型。</p><p>这里列出所有获取多个节点的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_elements_by_id</span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><h2 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port time</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">input.clear()</span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><p>Selenium可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作</p><h2 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p>打开网页中的一个拖曳实例，然后依次选中要拖曳的节点和拖曳到的目标节点。</p><h2 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure><p>对于某些操作，Selenium API并没有提供。比如，下拉进度条，它可以直接模拟运行JavaScript，此时使用execute_script()方法即可实现。</p><h2 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h2><p>既然Selenium已经提供了选择节点的方法，返回的是WebElement类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，我们就可以不用通过解析源代码来提取信息了，非常方便。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element_by_id(<span class="string">'zh-top-link-logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.get_attribute(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure><p>运行之后，程序便会驱动浏览器打开知乎页面，然后获取知乎的logo节点，最后打印出它的class。</p><h3 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a>获取文本值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rom selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.text)</span><br></pre></td></tr></table></figure><p>这里依然先打开知乎页面，然后获取“提问”按钮这个节点，再将其文本值打印出来。</p><h3 id="获取id、位置、标签名和大小"><a href="#获取id、位置、标签名和大小" class="headerlink" title="获取id、位置、标签名和大小"></a>获取id、位置、标签名和大小</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'https://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.id)</span><br><span class="line">print(input.location)</span><br><span class="line">print(input.tag_name)</span><br><span class="line">print(input.size)</span><br></pre></td></tr></table></figure><p>这里首先获得“提问”按钮这个节点，然后调用其id、location、tag_name、size属性来获取对应的属性值。</p><h2 id="切换Frame"><a href="#切换Frame" class="headerlink" title="切换Frame"></a>切换Frame</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure><p>这里还是以前面演示动作链操作的网页为实例，首先通过switch_to.frame()方法切换到子Frame里面，然后尝试获取父级Frame里的logo节点（这是不能找到的），如果找不到的话，就会抛出NoSuchElementException异常，异常被捕捉之后，就会输出NO LOGO。接下来，重新切换回父级Frame，然后再次重新获取节点，发现此时可以成功获取了。</p><h2 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h2><p>这里等待的方式有两种：一种是隐式等待，一种是显式等待。</p><h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure><p>这里我们用implicitly_wait()方法实现了隐式等待。</p><h3 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h3><p>隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))</span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure><p>这里还有一种更合适的显式等待方法，它指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。</p><h2 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.python.org/'</span>)</span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>平常使用浏览器时都有前进和后退功能，Selenium也可以完成这个操作，它使用back()方法后退，使用forward()方法前进。</p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'germey'</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><p>使用Selenium，还可以方便地对Cookies进行操作，例如获取、添加、删除Cookies等。</p><h2 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h2><p>在访问网页的时候，会开启一个个选项卡。在Selenium中，我们也可以对选项卡进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在使用Selenium的过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行了。这里我们可以使用try except语句来捕获各种异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line"> </span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    print(<span class="string">'Time Out'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了，通过本篇文章希望大家可以基本上了解 Selenium 库结合浏览器驱动的一些使用方法。我们例子里使用的是Chrome，不妨大家尝试在代码里使用一下 PhantomJs，因为它是无界面的，运行起来相对好一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，这篇文章我们来看一下 Selenium 库结合、Chrome，Firefox，Edge 等一些浏览器的操作。本章中，就让我们来感受一下它的强大之处吧。&lt;/p&gt;
&lt;h2 id=&quot;什么是Selenium&quot;&gt;&lt;a href=&quot;#什么是Selenium&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--分析Ajax请求爬取今日头条街拍美图(7)</title>
    <link href="https://andchen.com/2018/07/25/Python/"/>
    <id>https://andchen.com/2018/07/25/Python/</id>
    <published>2018-07-25T02:48:19.000Z</published>
    <updated>2018-07-25T04:25:25.711Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章我们来研究一下怎么分析网页的Ajax请求。</p><p>我们在平时爬取网页的时候，可能都遇到过有些网页直接请求得到的 HTML 代码里面，并没有我们需要的数据，也就是我们在浏览器中看到的内容。</p><p>这就是因为这些信息是通过Ajax加载的，并且通过js渲染生成的。这个时候我们就需要分析这个网页的请求了。</p><h3 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h3><p>Ajax，全称为Asynchronous JavaScript and XML，即异步的JavaScript和XML。它不是一门编程语言，而是利用JavaScript在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p><p>比如：拿微博来说，我们以我的个人的主页为例，切换到微博页面，一直下滑，可以发现下滑几个微博之后，再向下就没有了，转而会出现一个加载的动画，不一会儿下方就继续出现了新的微博内容，也就意味着页面的链接没有变化，但是网页中却多了新内容，也就是后面刷出来的新微博。这就是通过Ajax获取新数据并呈现的过程。</p><h3 id="爬取分析"><a href="#爬取分析" class="headerlink" title="爬取分析"></a>爬取分析</h3><p>我们目标网站就以今日头条街拍美图来进行分析。</p><p>在抓取之前，首先要分析抓取的逻辑。打开今日头条的首页：<a href="http://www.toutiao.com/" target="_blank" rel="noopener">地址</a> 如下：</p><img src="/2018/07/25/Python/img1.jpg"><p>右上角有一个搜索入口，这里尝试抓取街拍美图，所以输入“街拍”二字搜索一下，如下：</p><img src="/2018/07/25/Python/img2.jpg"><h4 id="那我们要怎么获得所有页的数据呢？"><a href="#那我们要怎么获得所有页的数据呢？" class="headerlink" title="那我们要怎么获得所有页的数据呢？"></a>那我们要怎么获得所有页的数据呢？</h4><p>我们在Chrome中打开开发者工具(F12)。我们点击Network，点击XHR标签。然后我们刷新网页，往下拉请求。这个时候我们就可以看到XHR标签，在网页每一次加载的时候就会跳出一个请求。</p><p>我们点击第一个请求，可以看到它的参数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset: 0</span><br><span class="line">format: json</span><br><span class="line">keyword: 街拍</span><br><span class="line">autoload: true</span><br><span class="line">count: 20</span><br></pre></td></tr></table></figure></p><p>在点击第二个请求参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offset: 1</span><br><span class="line">format: json</span><br><span class="line">keyword: 街拍</span><br><span class="line">autoload: true</span><br><span class="line">count: 20</span><br></pre></td></tr></table></figure><p>我们可以看到，这一个GET请求，请求URL的参数有offset、format、keyword、autoload、count和cur_tab。我们需要找出这些参数的规律，因为这样才可以方便地用程序构造出来。</p><img src="/2018/07/25/Python/img3.jpg"><p>好了，分析到这里，如果想了解更多，你们可以进行实现一下这个过程。</p><h3 id="爬取流程"><a href="#爬取流程" class="headerlink" title="爬取流程"></a>爬取流程</h3><p>分析Ajax请求获得文章的 url 信息;</p><p>解析每一篇文章，获得需要的数据内容;</p><p>将获取的数据保存下来;</p><p>开启去多进程，大量抓取。</p><h3 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h3><p>首先，实现方法 get_page() 来加载单个 Ajax 请求的结果。其中唯一变化的参数就是 offset，所以我们将它当作参数传递，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(offset)</span>:</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'offset'</span>: offset,</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'json'</span>,</span><br><span class="line">        <span class="string">'keyword'</span>: <span class="string">'街拍'</span>,</span><br><span class="line">        <span class="string">'autoload'</span>: <span class="string">'true'</span>,</span><br><span class="line">        <span class="string">'count'</span>: <span class="string">'20'</span>,</span><br><span class="line">        <span class="string">'cur_tab'</span>: <span class="string">'1'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">'http://www.toutiao.com/search_content/?'</span> + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>这里我们用urlencode()方法构造请求的GET参数，然后用requests请求这个链接，如果返回状态码为200，则调用response的json()方法将结果转为JSON格式，然后返回。</p><p>接下来，再实现一下解析方法：提取每条数据的 image_detail 字段中的每一张图片链接，将图片链接和图片所属的标题并返回，此时可以构造一个生成器。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_images</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> json.get(<span class="string">'data'</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> json.get(<span class="string">'data'</span>):</span><br><span class="line">            title = item.get(<span class="string">'title'</span>)</span><br><span class="line">            images = item.get(<span class="string">'image_detail'</span>)</span><br><span class="line">            <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">                <span class="keyword">yield</span> &#123;</span><br><span class="line">                    <span class="string">'image'</span>: image.get(<span class="string">'url'</span>),</span><br><span class="line">                    <span class="string">'title'</span>: title</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>接下来，实现一个保存图片的方法save_image(),其中 item 就是前面 get_images() 方法返回的一个字典。在这里，首先根据 item 的 title 来创建文件夹，然后请求这个图片链接，获取图片的二进制数据，以二进制的形式写入文件。图片的名称可以使用其内容的MD5值，这样可以去除重复。相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(item.get(<span class="string">'title'</span>)):</span><br><span class="line">        os.mkdir(item.get(<span class="string">'title'</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(item.get(<span class="string">'image'</span>))</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            file_path = <span class="string">'&#123;0&#125;/&#123;1&#125;.&#123;2&#125;'</span>.format(item.get(<span class="string">'title'</span>), md5(response.content).hexdigest(), <span class="string">'jpg'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">                <span class="keyword">with</span> open(file_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(response.content)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'Already Downloaded'</span>, file_path)</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">        print(<span class="string">'Failed to Save Image'</span>)</span><br></pre></td></tr></table></figure><p>最后，只要构造一个 offset 数组，遍历 offset，提取图片链接，并将其下载:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    json = get_page(offset)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> get_images(json):</span><br><span class="line">        print(item)</span><br><span class="line">        save_image(item)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">GROUP_START = <span class="number">1</span></span><br><span class="line">GROUP_END = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool()</span><br><span class="line">    groups = ([x * <span class="number">20</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(GROUP_START, GROUP_END + <span class="number">1</span>)])</span><br><span class="line">    pool.map(main, groups)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>这里利用了多线程的线程池，调用其map()方法实现多线程下载。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/Andchenn/Jiepai" target="_blank" rel="noopener">here</a></p><p>好了，对于一些使用Ajax加载的网页，我们就可以这么抓取了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章我们来研究一下怎么分析网页的Ajax请求。&lt;/p&gt;
&lt;p&gt;我们在平时爬取网页的时候，可能都遇到过有些网页直接请求得到的 HTML 代码里面，并没有我们需要的数据，也就是我们在浏览器中看到的内容。&lt;/p&gt;
&lt;p&gt;这就是因为这些信息是通过Ajax加载的，并且通过js渲染
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--帅啊，帅哥图(6)</title>
    <link href="https://andchen.com/2018/07/23/Python/"/>
    <id>https://andchen.com/2018/07/23/Python/</id>
    <published>2018-07-23T02:53:53.000Z</published>
    <updated>2018-07-25T04:27:46.913Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中我们抓取了实例的数据，如果大家运行成功，并且看到文件夹下的 txt 文件了。是不是很欣喜。和上一篇实践不同，我们这次来爬取 <a href="http://www.shuaia.net&quot;Markdown&quot;" target="_blank" rel="noopener">帅啊</a> 全站帅哥图，并且保存指定文件夹下。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>通过上一篇文章的爬取过程，我们基本上理解了抓取一个网站的大致流程。因为一个网站虽然有很多页，但是大部分网站每一页的HTML标签内容都是相同的。我们只要获取到一页的内容，就可以获得所有页的内容了。那么开始吧。</p><p>我们先获得源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.shuaia.net/index.html'</span> </span><br><span class="line">headers = &#123;</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span><span class="string">"Chrome/58.0.3029.110 Safari/537.36 "</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(url=url, headers=headers)</span><br><span class="line">r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">html = r.text   </span><br><span class="line">bf = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><p>通过URL，得到所需的页数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        url = <span class="string">'http://www.shuaia.net/index.html'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = <span class="string">'http://www.shuaia.net/index_%d.html'</span> % num</span><br></pre></td></tr></table></figure><p> 得到页数后，我们利用循环就可以得到所需页的内容了：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> targets_url:</span><br><span class="line">    list_url.append(each.img.get(<span class="string">'alt'</span>) + <span class="string">'='</span> + each.get(<span class="string">'href'</span>))</span><br></pre></td></tr></table></figure><p>我们通过循环下载图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each_img <span class="keyword">in</span> list_url:</span><br><span class="line">   img_info = each_img.split(<span class="string">'='</span>)</span><br><span class="line">   targets_url = img_info[<span class="number">1</span>]</span><br><span class="line">   filename = img_info[<span class="number">0</span>] + <span class="string">'.jpg'</span></span><br><span class="line">   print(<span class="string">'下载：'</span> + filename)</span><br></pre></td></tr></table></figure><p>好了，爬虫程序到这里基本上已经全部实现了。我们创建一个 images 文件夹之前，先判断文件夹是否存在，然后存放在代码所在的文件中，这里需要用的Python内置的os库了，不清楚的伙伴可以自己查看资料哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'images'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir():</span><br><span class="line">    os.makedirs(<span class="string">'images'</span>)</span><br><span class="line">    urlretrieve(url=img_url,filename=<span class="string">'images/'</span> + filename)</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>好了，最后上一下完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, json, time, os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list_url = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">            url = <span class="string">'http://www.shuaia.net/index.html'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            url = <span class="string">'http://www.shuaia.net/index_%d.html'</span> % num</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span><span class="string">"Chrome/58.0.3029.110 Safari/537.36 "</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r = requests.get(url=url, headers=headers)</span><br><span class="line">        r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        html = r.text</span><br><span class="line">        bf = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">        targets_url = bf.find_all(class_=<span class="string">'item-img'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> targets_url:</span><br><span class="line">            list_url.append(each.img.get(<span class="string">'alt'</span>) + <span class="string">'='</span> + each.get(<span class="string">'href'</span>))</span><br><span class="line">    print(<span class="string">'连接采集完成'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each_img <span class="keyword">in</span> list_url:</span><br><span class="line">        img_info = each_img.split(<span class="string">'='</span>)</span><br><span class="line">        targets_url = img_info[<span class="number">1</span>]</span><br><span class="line">        filename = img_info[<span class="number">0</span>] + <span class="string">'.jpg'</span></span><br><span class="line">        print(<span class="string">'下载：'</span> + filename)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) "</span></span><br><span class="line">                          <span class="string">"Chrome/58.0.3029.110 Safari/537.36 "</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        img_req = requests.get(url=targets_url, headers=headers)</span><br><span class="line">        img_req.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        img_html = img_req.text</span><br><span class="line">        img_bf_1 = BeautifulSoup(img_html, <span class="string">'lxml'</span>)</span><br><span class="line">        img_url = img_bf_1.find_all(<span class="string">'div'</span>, class_=<span class="string">'wr-single-content-list'</span>)</span><br><span class="line">        img_bf_2 = BeautifulSoup(str(img_url), <span class="string">'lxml'</span>)</span><br><span class="line">        img_url = <span class="string">'http://www.shuaia.net'</span> + img_bf_2.div.img.get(<span class="string">'src'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'images'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir():</span><br><span class="line">            os.makedirs(<span class="string">'images'</span>)</span><br><span class="line">        urlretrieve(url=img_url, filename=<span class="string">'images/'</span> + filename)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'下载完成！'</span>)</span><br></pre></td></tr></table></figure><p>最后，我们就相互鼓励一下，加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章中我们抓取了实例的数据，如果大家运行成功，并且看到文件夹下的 txt 文件了。是不是很欣喜。和上一篇实践不同，我们这次来爬取 &lt;a href=&quot;http://www.shuaia.net&amp;quot;Markdown&amp;quot;&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--实战(5)</title>
    <link href="https://andchen.com/2018/07/19/Python/"/>
    <id>https://andchen.com/2018/07/19/Python/</id>
    <published>2018-07-19T07:35:26.000Z</published>
    <updated>2018-07-19T08:04:54.916Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我贴出两种方式实战内容，一个运用正则表达式，另一个运用 BeautifulSoup 来写的，之前没有过多介绍正则表达式的用法，今天看一下实例，了解一下。而我推荐大家用 BeautifulSoup 来爬取数据。毕竟每个人的兴趣不一，或许还有其他方法，看你个人喜欢用哪种爬虫，就用哪种吧！我个人喜欢用 BeautifulSoup 强大的解析工具爬虫。</p><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>运用正则表达式进行抓取数据，看下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                          <span class="string">'Chrome/65.0.3325.162 Safari/537.36 '</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(\d+)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a'</span></span><br><span class="line">                         + <span class="string">'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">                         + <span class="string">'.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>] + item[<span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=<span class="keyword">False</span>) + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url = <span class="string">'http://maoyan.com/board/4?offset='</span> + str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(offset=i * <span class="number">10</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>我们通过爬取猫眼TOP100的电影信息练习了正则表达式的用法。详细就不多说，想知道更多就 google 吧。</p><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>运用 BeautifulSoup 强大解析工具来抓取数据，看下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求获得HTML源码的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 伪装成浏览器访问服务器</span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                             <span class="string">'Chrome/58.0.3029.110 Safari/537.36'</span>&#125;</span><br><span class="line">    r = requests.get(url, headers=headers).text</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析页面，获得数据信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_parse</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 调用函数，for循环迭代出所有页面</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> all_page():</span><br><span class="line">        <span class="comment"># BeautifulSoup的解析</span></span><br><span class="line">        soup = BeautifulSoup(get_html(url), <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="comment"># 书名</span></span><br><span class="line">        alldiv = soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'pl2'</span>)</span><br><span class="line">        names = [a.find(<span class="string">'a'</span>)[<span class="string">'title'</span>] <span class="keyword">for</span> a <span class="keyword">in</span> alldiv]</span><br><span class="line">        <span class="comment"># 作者</span></span><br><span class="line">        allp = soup.find_all(<span class="string">'p'</span>, class_=<span class="string">'pl'</span>)</span><br><span class="line">        authors = [p.get_text() <span class="keyword">for</span> p <span class="keyword">in</span> allp]</span><br><span class="line">        <span class="comment"># 评分</span></span><br><span class="line">        starspan = soup.find_all(<span class="string">'span'</span>, class_=<span class="string">'rating_nums'</span>)</span><br><span class="line">        scores = [s.get_text() <span class="keyword">for</span> s <span class="keyword">in</span> starspan]</span><br><span class="line">        <span class="comment"># 简介</span></span><br><span class="line">        sum_div = soup.select(<span class="string">'tr.item &gt; td:nth-of-type(2)'</span>)</span><br><span class="line">        sums = []</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> sum_div:</span><br><span class="line">            sumspan = d.find(<span class="string">'span'</span>, class_=<span class="string">'inq'</span>)</span><br><span class="line">            summary = sumspan.get_text() <span class="keyword">if</span> sumspan <span class="keyword">else</span> <span class="string">'无'</span></span><br><span class="line">            sums.append(summary)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, author, score, sum <span class="keyword">in</span> zip(names, authors, scores, sums):</span><br><span class="line">            name = <span class="string">'书名'</span> + str(name) + <span class="string">'\n'</span></span><br><span class="line">            author = <span class="string">'作者'</span> + str(author) + <span class="string">'\n'</span></span><br><span class="line">            score = <span class="string">'评分'</span> + str(score) + <span class="string">'\n'</span></span><br><span class="line">            sum = <span class="string">'简介'</span> + str(sum) + <span class="string">'\n'</span></span><br><span class="line">            data = name + author + score + sum</span><br><span class="line">            <span class="comment"># 保存数据</span></span><br><span class="line">            f.writelines(data + <span class="string">'====================='</span> + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有页面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_page</span><span class="params">()</span>:</span></span><br><span class="line">    base_url = <span class="string">'https://book.douban.com/top250?start='</span></span><br><span class="line">    urllist = []</span><br><span class="line">    <span class="comment"># 从0到255,间隔25的数组</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">        allurl = base_url + str(page)</span><br><span class="line">        urllist.append(allurl)</span><br><span class="line">    <span class="keyword">return</span> urllist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名</span></span><br><span class="line">filename = <span class="string">'豆瓣图书Top250.txt'</span></span><br><span class="line"><span class="comment"># 保存文件操作</span></span><br><span class="line">f = open(filename, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">html_parse()</span><br><span class="line">f.close()</span><br><span class="line">print(<span class="string">'保存成功'</span>)</span><br></pre></td></tr></table></figure><p>上一章已经学过 BeautifulSoup 强大解析工具的用法，相信大家都掌握了，通过这个豆瓣图书Top250实例，可以对大家学习过的 BeautifulSoup 进行练手，然后更牢固扎根基础知识。</p><p>最后，大家一起努力吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，我贴出两种方式实战内容，一个运用正则表达式，另一个运用 BeautifulSoup 来写的，之前没有过多介绍正则表达式的用法，今天看一下实例，了解一下。而我推荐大家用 BeautifulSoup 来爬取数据。毕竟每个人的兴趣不一，或许还有其他方法，看你个人喜欢用哪种爬
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--使用Beautiful Soup(4)</title>
    <link href="https://andchen.com/2018/07/18/Python/"/>
    <id>https://andchen.com/2018/07/18/Python/</id>
    <published>2018-07-18T06:55:37.000Z</published>
    <updated>2018-07-18T08:10:24.941Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家对 Requests 库的用法已经很熟练了，今天我讲一个强大的解析工具Beautiful Soup，它借助网页的结构和属性等特性来解析网页。有了它，我们不用再去写一些复杂的正则表达式，只需要简单的几条语句，就可以完成网页中某个元素的提取。</p><h2 id="什么是BeautifulSoup？"><a href="#什么是BeautifulSoup？" class="headerlink" title="什么是BeautifulSoup？"></a>什么是BeautifulSoup？</h2><p>Python的网页解析可以用正则表达式去完成，那么我们在写的时候，要挨个的去把代码拿出来匹配，而且还要写匹配的规则，整体实现起来就很复杂。BeautifulSoup呢，它是一个方便的网页解析库，处理高效，支持多种解析器。大部分情况下，利用它我们不在需要编写正则表达式就可以方便的实现网页信息的提取。</p><p>BeautifulSoup是一个网页解析库，它支持很多解析器，不过最主流的有两个。一个是Python标准库，一个是lxml HTML 解析器。两者的使用方法相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的标准库</span></span><br><span class="line">BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line"><span class="comment"># lxml</span></span><br><span class="line">BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br></pre></td></tr></table></figure><p>Python内置标准库的执行速度一般，但是低版本的Python中，中文的容错能力比较差。lxmlHTML 解析器的执行速度快，但是需要安装 C语言的依赖库。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始之前，请确保已经正确安装好了Beautiful Soup和lxml，如果没有安装,看下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br><span class="line">pip install lxml</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>下面首先用实例来看看Beautiful Soup的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title.string)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse's story</span><br><span class="line">  &lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;p class="title" name="dromouse"&gt;</span><br><span class="line">   &lt;b&gt;</span><br><span class="line">    The Dormouse's story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   Once upon a time there were three little sisters; and their names were</span><br><span class="line">   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   and</span><br><span class="line">   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line">and they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">The Dormouse's story</span><br></pre></td></tr></table></figure><p>你看，我们可以通过简单调用几个属性完成文本提取，这是不是非常方便？</p><h2 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h2><h3 id="获取名称"><a href="#获取名称" class="headerlink" title="获取名称"></a>获取名称</h3><p>可以利用name属性获取节点的名称。这里还是以上面的文本为例，选取title节点，然后调用name属性就可以得到节点名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printp (soup.title.name)</span><br></pre></td></tr></table></figure><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>每个节点可能有多个属性，比如id和class等，选择这个节点元素后，可以调用attrs获取所有属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.attrs)</span><br><span class="line">print(soup.p.attrs[<span class="string">'name'</span>])</span><br></pre></td></tr></table></figure><h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printp (soup.p.string)</span><br></pre></td></tr></table></figure><h2 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h2><p>虽然BeautifulSoup的基本用法，标签获取，内容获取，可以解析一些 html代码。但是在遇到很多复杂的页面时，上面的方法是完全不足的，或者是很繁琐的，因为有时候有的标签会有几个属性（class、id等）。</p><p>索性BeautifulSoup给我们提供了很方便的方法选择器，也就是 API 方法，这里着重介绍2个: find() 和 find_all() 。其它方法的参数和用法类似,大家举一反三吧。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h3><p>find_all，顾名思义，就是查询所有符合条件的元素。给它传入一些属性或文本，就可以得到符合条件的元素，它的功能十分强大。</p><p>它的API如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_all(name , attrs , recursive , text , **kwargs)</span><br></pre></td></tr></table></figure><h4 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h4><p>我们可以根据节点名来查询元素，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.find_all(name=<span class="string">'ul'</span>))</span><br></pre></td></tr></table></figure><h4 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h4><p>除了根据节点名查询，我们也可以传入一些属性来查询，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.find_all(attrs=&#123;<span class="string">'name'</span>: <span class="string">'elements'</span>&#125;))</span><br></pre></td></tr></table></figure><h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p>text参数可用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">html=<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string">        &lt;a&gt;Hello, this is a link&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find_all(text=re.compile(<span class="string">'link'</span>)))</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>除了find_all()方法，还有find()方法，只不过后者返回的是单个元素，也就是第一个匹配的元素，而前者返回的是所有匹配的元素组成的列表。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html=<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string">        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="list list-small" id="list-2"&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find(name=<span class="string">'ul'</span>))</span><br><span class="line">print(soup.find(class_=<span class="string">'list'</span>))</span><br></pre></td></tr></table></figure><p>find_all()、find()方法完全相同，只不过查询范围不同。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>Beautiful Soup还提供了另外一种选择器，那就是CSS选择器。如果对Web开发熟悉的话，那么对CSS选择器肯定也不陌生。</p><h3 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h3><p>select()方法同样支持嵌套选择。例如，先选择所有ul节点，再遍历每个ul节点，选择其li节点，样例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">    print(ul.select(<span class="string">'li'</span>))</span><br></pre></td></tr></table></figure><p>运行后可以看到，这里正常输出了所有ul节点下所有li节点组成的列表。</p><h3 id="获取属性-1"><a href="#获取属性-1" class="headerlink" title="获取属性"></a>获取属性</h3><p>我们知道节点类型是Tag类型，所以获取属性还可以用原来的方法。仍然是上面的HTML文本，这里尝试获取每个ul节点的id属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">    print(ul[<span class="string">'id'</span>])</span><br><span class="line">    print(ul.attrs[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure><p>运行后可以看到，直接传入中括号和属性名，以及通过attrs属性获取属性值，都可以成功。</p><h3 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h3><p>要获取文本，当然也可以用前面所讲的string属性。此外，还有一个方法，那就是get_text()，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> soup.select(<span class="string">'li'</span>):</span><br><span class="line">    print(<span class="string">'Get Text:'</span>, li.get_text())</span><br><span class="line">    print(<span class="string">'String:'</span>, li.string)</span><br></pre></td></tr></table></figure><p>运行后可以看到，二者的效果完全一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推荐使用lxml解析库，必要时使用html.parser。<br>节点选择筛选功能弱但是速度快。<br>建议使用find()或者find_all()查询匹配单个结果或者多个结果。<br>如果对CSS选择器熟悉的话，可以使用select()方法选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信大家对 Requests 库的用法已经很熟练了，今天我讲一个强大的解析工具Beautiful Soup，它借助网页的结构和属性等特性来解析网页。有了它，我们不用再去写一些复杂的正则表达式，只需要简单的几条语句，就可以完成网页中某个元素的提取。&lt;/p&gt;
&lt;h2 id=&quot;什
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--高级用法(3)</title>
    <link href="https://andchen.com/2018/07/17/Python/"/>
    <id>https://andchen.com/2018/07/17/Python/</id>
    <published>2018-07-17T00:42:12.000Z</published>
    <updated>2018-07-17T02:29:34.437Z</updated>
    
    <content type="html"><![CDATA[<p>在前一节中，我们了解了requests的基本用法，如基本的GET、POST请求以及Response对象。本节中，我们再来了解下requests的一些高级用法，如文件上传、cookie设置、代理设置等。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>文件上传的操作只要我们从文件夹中把文件读取出来，并且赋值给 files 参数，就可以了，打印出源代码我们就可以看待上传文件的字节流了。</p><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(r.cookies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">    print(key + <span class="string">'='</span> + value)</span><br></pre></td></tr></table></figure><p>通过获取字典的键值对来查看 Cookie.</p><h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><p>在requests中，如果直接利用get()或post()等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的会话，也就是说相当于你用了两个浏览器打开了不同的页面。</p><p>有朋友可能说了，我在两次请求时设置一样的cookies不就行了？可以，但这样做起来显得很烦琐，我们有更简单的解决方法。</p><p>其实解决这个问题的主要方法就是维持同一个会话，也就是相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但是我又不想每次设置cookies，那该怎么办呢？这时候就有了新的利器——Session对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>所以，利用Session，可以做到模拟同一个会话而不用担心Cookies的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p><h3 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h3><p>此外，requests还提供了证书验证的功能。当发送HTTP请求的时候，它会检查SSL证书，我们可以使用verify参数控制是否检查此证书。其实如果不加verify参数的话，默认是True，会自动验证。</p><p>现在我们用requests来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>运行后提示一个错误 SSLError，表示证书验证错误。所以，如果请求一个 HTTPS 站点，但是证书验证错误页面时，<br>就会报这样的错误，那么怎么避免这个错误呢？很简单，把 verify 参数设置为 False 即可。相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>不过我们发现报了一个警告，他建议我们给它指定证书。我们可以通过忽略警告的方式来屏蔽这个警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"> </span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>或者通过捕捉警告到日志的方式忽略警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">logging.captureWarnings(<span class="keyword">True</span>)</span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, verify=<span class="keyword">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>当然，我们也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.12306.cn'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/key'</span>))</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure><p>当然，上面的代码是演示实例，我们需要有crt和key文件，并且指定它们的路径。注意，本地私有证书的key必须是解密状态，加密状态的key是不支持的。当然，上面的代码是演示实例，我们需要有crt和key文件，并且指定它们的路径。注意，本地私有证书的key必须是解密状态，加密状态的key是不支持的。</p><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的IP，导致一定时间段内无法访问。</p><p>那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到proxies参数。可以用这样的方式设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</span><br><span class="line">  <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">requests.get(<span class="string">"https://www.taobao.com"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><p>当然，直接运行这个实例可能不行，因为这个代理可能是无效的，请换成自己的有效代理试验一下。</p><p>除了基本的HTTP代理外，requests还支持SOCKS协议的代理。</p><p>首先，需要安装socks这个库:<br>pip3 install ‘requests[socks]’</p><p>然后就可以使用SOCKS协议代理了，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'socks5://user:password@host:port'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'socks5://user:password@host:port'</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">"https://www.taobao.com"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到timeout参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">"https://www.taobao.com"</span>, timeout = <span class="number">1</span>)</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><p>如果想永久等待，可以直接将timeout设置为None，或者不设置直接留空，因为默认是None。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://www.taobao.com'</span>, timeout=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>或直接不加参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">'https://www.taobao.com'</span>)</span><br></pre></td></tr></table></figure><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>有一些网站在访问的时候需要我们输入用户名和密码，那么这种网站我们要怎样处理呢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">'http://localhost:5000'</span>, auth=HTTPBasicAuth(<span class="string">'username'</span>, <span class="string">'password'</span>))</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><p>调用HTTPBasicAuth类，直接传入用户名和密码就可以了。</p><h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">     <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">r = Request(<span class="string">'POST'</span>, url, data=data, headers=headers)</span><br><span class="line">prepped = s.prepare_request(r)</span><br><span class="line">r = s.send(prepped)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>可以看到，我们达到了同样的POST请求效果。</p><p>最后，今天讲解了requests的一些高级用法，这些用法在后面实战部分会经常用到，需要熟练掌握。我们共同努力吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前一节中，我们了解了requests的基本用法，如基本的GET、POST请求以及Response对象。本节中，我们再来了解下requests的一些高级用法，如文件上传、cookie设置、代理设置等。&lt;/p&gt;
&lt;h3 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; cl
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫--requests的基本用法(2)</title>
    <link href="https://andchen.com/2018/07/16/Python/"/>
    <id>https://andchen.com/2018/07/16/Python/</id>
    <published>2018-07-16T05:20:07.000Z</published>
    <updated>2018-07-16T07:24:54.203Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用，但是我并不推荐。因为 urllib 在很多时候确实有不方便的地方，比如处理网页验证和 Cookies 时，需要写 Opener 和 Handler 来处理。为了更加方便地实现这些操作，就有了更为强大的库 requests，有了它，Cookies、登录验证、代理设置等操作都不是事儿。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始之前，请确保已经安装好了 requests 库。如果没有安装，安装也很简单：pip install requests</p><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(type(r.text))</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.cookies)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">&lt;class 'str'&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...HTML网页源码...</span></span><br><span class="line">&lt;RequestsCookieJar[]&gt;</span><br></pre></td></tr></table></figure><p>通过运行结果可以发现，我们很方便就获取到了Cookies.</p><h3 id="各种请求类型"><a href="#各种请求类型" class="headerlink" title="各种请求类型"></a>各种请求类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>)</span><br><span class="line">r = requests.put(<span class="string">'http://httpbin.org/put'</span>)</span><br><span class="line">r = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span><br><span class="line">r = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">r = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure><p>这里分别用post()、put()、delete()等方法实现了POST、PUT、DELETE等请求。其实这只是冰山一角，更多的还在后面。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>HTTP中最常用的请求之一就是GET请求，运行成功你就会看到源码了。</p><h3 id="带参数GET请求"><a href="#带参数GET请求" class="headerlink" title="带参数GET请求"></a>带参数GET请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>是不是感觉很简单，传入参数只需要我们把数据生成字典，调用 params 这个参数赋值就好了。</p><h3 id="解析-json"><a href="#解析-json" class="headerlink" title="解析 json()"></a>解析 json()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">print(type(r.text))</span><br><span class="line">print(r.json())</span><br><span class="line">print(type(r.json()))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class 'str'&gt;</span><br><span class="line">&#123;'headers': &#123;'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.10.0'&#125;, 'url': 'http://httpbin.org/get', 'args': &#123;&#125;, 'origin': '182.33.248.131'&#125;</span><br><span class="line">&lt;class 'dict'&gt;</span><br></pre></td></tr></table></figure><p>可以发现，调用json()方法，就可以将返回结果是JSON格式的字符串转化为字典。</p><h3 id="获取二进制数据"><a href="#获取二进制数据" class="headerlink" title="获取二进制数据"></a>获取二进制数据</h3><p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制码。</p><p>下面以GitHub的站点图标为例来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.content)</span><br></pre></td></tr></table></figure><p>接着，我们将刚才提取到的图片保存下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></table></figure><p>同样地，音频和视频文件也可以用这种方法获取。</p><h3 id="添加-headers"><a href="#添加-headers" class="headerlink" title="添加 headers"></a>添加 headers</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">"https://www.zhihu.com/explore"</span>, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>有些网页如果我们直接去请求的话，他会查看请求的对象是不是浏览器，如果没有浏览器信息就会禁止我们爬虫的访问，这个时候我们就要给爬虫加一个headers，加一个浏览器的user-agent信息。这样我们就可以正常访问了。如果有的朋友不知道怎么得到User-Agent，可以按F12，找到network，然后刷新页面就看到了。</p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>前面我们了解了最基本的GET请求，另外一种比较常见的请求方式是POST。使用requests实现POST请求同样非常简单，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'germey'</span>, <span class="string">'age'</span>: <span class="string">'22'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"data"</span>: <span class="string">""</span>, </span><br><span class="line">  <span class="attr">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"form"</span>: &#123;</span><br><span class="line">    <span class="attr">"age"</span>: <span class="string">"22"</span>, </span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"germey"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="attr">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="attr">"Content-Length"</span>: <span class="string">"18"</span>, </span><br><span class="line">    <span class="attr">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"python-requests/2.10.0"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"json"</span>: <span class="literal">null</span>, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"182.33.248.131"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，我们成功获得了返回结果，其中form部分就是提交的数据，这就证明POST请求成功发送了。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="响应的属性"><a href="#响应的属性" class="headerlink" title="响应的属性"></a>响应的属性</h3><p>发送请求后，得到的自然就是响应。在上面的实例中，我们使用text和content获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如状态码、响应头、Cookies等。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line">print(type(r.status_code), r.status_code) <span class="comment"># 状态码</span></span><br><span class="line">print(type(r.headers), r.headers) <span class="comment"># 响应头</span></span><br><span class="line">print(type(r.cookies), r.cookies) <span class="comment"># Cookies</span></span><br><span class="line">print(type(r.url), r.url) <span class="comment"># URL</span></span><br><span class="line">print(type(r.history), r.history) <span class="comment"># 访问历史记录</span></span><br></pre></td></tr></table></figure><h3 id="状态码查询"><a href="#状态码查询" class="headerlink" title="状态码查询"></a>状态码查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> r.status_code == <span class="number">200</span> <span class="keyword">else</span> print(<span class="string">'Request Successfully'</span>)</span><br></pre></td></tr></table></figure><p>如果发送了一个错误请求(一个4XX客户端错误)，我们可以通过 requests.codes.not_found 来抛出异常。</p><p>好了，requests 库的基本语法操作，就讲述到这里，相信大家对 requsts 库已经有一定的了解了，希望我们共同学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然 urllib 库，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用，但是我并不推荐。因为 urllib 在很多时候确实有不方便的地方，比如处理网页验证和 Cookies 时，需要写 Opener 和 Handler 来处理。为了更加方便地实
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬虫--基本原理(1)</title>
    <link href="https://andchen.com/2018/07/12/Python/"/>
    <id>https://andchen.com/2018/07/12/Python/</id>
    <published>2018-07-12T04:14:52.000Z</published>
    <updated>2018-07-12T06:05:34.744Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是小白，来一起学习爬虫的基本原理。</p><p>这篇文章我来梳理一下爬虫的基本原理。用过 Python 的朋友都知道 Python 用来写爬虫是件很简单的事情。但是有的朋友不了解爬虫到底是什么，会想爬虫为什么设置请求头，请求体，到底要怎么去发送这个请求。当然也有的朋友使用过很多爬虫的库，解析库，写过很多爬虫案例，但是可能他们的思路脉络也不是太清晰。然而，你们的困惑我之前也有过。那么我就简单帮大家梳理一下爬虫原理。</p><h2 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h2><p>爬虫即网络爬虫（Web Spider），又被称为网页蜘蛛，是一种按照一定的规则，自动地抓取网站信息的程序或者脚本。</p><p>就如，我们在浏览器输入网址，回车，得到我们需要的网络信息。这就是浏览器请求网站的服务器，获取到网络资源。爬虫也相当于模拟浏览器发送请求，获得到HTML代码。HTML代码里通常包含了标签和文字信息，我们就从中提取到我们想要的信息。</p><p>通常爬虫是从某个网站的某个页面开始，爬取这个页面的内容，找到网页中的其他链接地址，然后从这个地址爬到下一个页面，这样一直不停的爬下去，进去批量的抓取信息。那么，我们可以看出网络爬虫就是一个不停爬取网页抓取信息的程序。</p><h2 id="爬虫的基本流程"><a href="#爬虫的基本流程" class="headerlink" title="爬虫的基本流程"></a>爬虫的基本流程</h2><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>通过 HTTP 库向目标站点发送请求，即发送一个 Request,然后等待服务器响应。这个请求的过程相当于浏览客户端在浏览器地址栏输入网址：<a href="https://www.google.com，然后点击回车，向服务端发送一次请求。" target="_blank" rel="noopener">https://www.google.com，然后点击回车，向服务端发送一次请求。</a></p><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>如果服务器能正常响应，我们会得到一个 Response，Response 的内容就是你所要获取的内容，这个过程就是服务器接收客户端的请求，类型可能有HTML、Json字符串，二进制数据等类型。进过解析发送给浏览器的网页HTML文件。</p><h3 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a>解析内容</h3><p>如果得到的内容是 HTML，可以网页解析库进行解析，得到的是 Json，可以转为 Json 对象解析。得到二进制数据，可以做保存或者进一步处理。这些就像浏览器吧服务器端的文件获取到本地，再进行解析并展现出来。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>保存的方式可以是把数据存为文本，也可以把数据保存到数据库等。</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="什么是-Request？"><a href="#什么是-Request？" class="headerlink" title="什么是 Request？"></a>什么是 Request？</h3><p>浏览器发送信息给该网址所在的服务器，这个过程就是做 HTTP Request。</p><h3 id="Request-中包含什么？"><a href="#Request-中包含什么？" class="headerlink" title="Request 中包含什么？"></a>Request 中包含什么？</h3><p>请求方式：请求方式的主要类型是GET，POST两种，另外还有HEAD、PUT、DELETE等。GET 请求的请求参数会显示在URL链接的后面，比如我们打开谷歌，搜索“图片”，我们会看到请求的URL链接为<a href="https://www.google.com/s?wd=图片。而" target="_blank" rel="noopener">https://www.google.com/s?wd=图片。而</a> POST 请求的请求参数会存放在Request内，并不会出现在 URL 链接的后面，比如我们登录QQ邮箱，输入用户名和密码，我们会看到浏览器开发者工具的Network页，Request请求有Form Data的键值对信息，那里就存放了我们的登录信息，有利于保护我们的账户信息安全。<br>请求 URL：URL 全称是统一资源定位符，也就是我们说的网址。比如一张图片，一个音乐文件，一个网页文档等都可以用唯一URL来确定，它包含的信息指出文件的位置以及浏览器应该怎么去处理它。<br>请求头(Request Headers)：请求头包含请求时的头部信息，如User-Agent（指定浏览器的请求头），authorization，Host，Cookies等信息。<br>请求体：请求体是请求是额外携带的数据，比如登录表单提交的登录信息数据。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="什么是-Response？"><a href="#什么是-Response？" class="headerlink" title="什么是 Response？"></a>什么是 Response？</h3><p>服务器收到浏览器发送的信息后，能够根据浏览器发送信息的内容，做出相应的处理，然后把信息回传给浏览器，这叫 HTTP Response。</p><h3 id="Response-中包含什么？"><a href="#Response-中包含什么？" class="headerlink" title="Response 中包含什么？"></a>Response 中包含什么？</h3><p>响应状态：有多种响应状态，如200代表成功，301跳转页面，404表示找不到页面，502表示服务器错误。<br>响应头(Response Headers)：比如内容类型，内容长度，服务器信息，设置 Cookie 等。<br>响应体：响应体主要的部分，包含了请求资源的内容，比如网页 HTML 代码，图片二进制数据等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天梳理了爬虫的基本流程，Request，Response，有兴趣的可以学习一下，我写得不好，请帮我指出，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家好，我是小白，来一起学习爬虫的基本原理。&lt;/p&gt;
&lt;p&gt;这篇文章我来梳理一下爬虫的基本原理。用过 Python 的朋友都知道 Python 用来写爬虫是件很简单的事情。但是有的朋友不了解爬虫到底是什么，会想爬虫为什么设置请求头，请求体，到底要怎么去发送这个请求。当然也有
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 实例</title>
    <link href="https://andchen.com/2018/07/02/Python/"/>
    <id>https://andchen.com/2018/07/02/Python/</id>
    <published>2018-07-02T02:56:27.000Z</published>
    <updated>2018-07-02T02:58:47.354Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇了一个 python 试题，让我很经惊讶，我想，噫～～怎么看起来那么眼熟，这不是高中的数学题目？用 python 怎么实现呢？</p><p>看实例，如下：</p><p>题目：两个乒乓球进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x，z比，请编程序找出三队赛手的名单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(ord(<span class="string">'x'</span>), ord(<span class="string">'z'</span>) + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(ord(<span class="string">'x'</span>), ord(<span class="string">'z'</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i != j:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(ord(<span class="string">'x'</span>), ord(<span class="string">'z'</span>) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> (i != k) <span class="keyword">and</span> (j != k):</span><br><span class="line">                    <span class="keyword">if</span> (i != ord(<span class="string">'x'</span>)) <span class="keyword">and</span> (k != ord(<span class="string">'x'</span>)) <span class="keyword">and</span> (k != ord(<span class="string">'z'</span>)):</span><br><span class="line">                        print(<span class="string">'order is a -- %s\t b -- %s\tc--%s'</span> % (chr(i), chr(j), chr(k)))</span><br></pre></td></tr></table></figure><p>我是小白，若上面的代码有错误的可以留言告诉我，我将不胜感激，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇了一个 python 试题，让我很经惊讶，我想，噫～～怎么看起来那么眼熟，这不是高中的数学题目？用 python 怎么实现呢？&lt;/p&gt;
&lt;p&gt;看实例，如下：&lt;/p&gt;
&lt;p&gt;题目：两个乒乓球进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的继承、属性读取方法和装饰器</title>
    <link href="https://andchen.com/2018/07/02/inherit/"/>
    <id>https://andchen.com/2018/07/02/inherit/</id>
    <published>2018-07-02T01:44:11.000Z</published>
    <updated>2018-07-02T03:04:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>似乎很久没有写博文了，那就进入主题吧，今天通过这篇文章来学习 Python 继承、属性读取方法和装饰器。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当一个类继承另一个类是，它将继承父类的所有功能(如变量和方法)。这有助于重用代码。</p><p>在下一个例子中我们首先创建一个叫做 Person 的类，然后创建两个派生类 Student 和 Teacher。当两个类都从 Person 类继承时，它们的类除了会有 Person 类的所有方法还会有自身用途的新方法和新变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回具有给定名称的Person对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_details</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回包含人名的字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回Student对象，采用name, branch, year 3个参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, branch, year)</span>:</span></span><br><span class="line">        Person.__init__(self, name)</span><br><span class="line">        self.branch = branch</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_details</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        返回包含学生具体信息的字符串</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125; student &#123;&#125; and is in &#123;&#125; year."</span>.format(self.name, self.branch, self.year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回Teacher 对象，采用字符串列表作为参数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, papers)</span>:</span></span><br><span class="line">        Person.__init__(self, name)</span><br><span class="line">        self.papers = papers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_details</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125; teacher &#123;&#125;"</span>.format(self.name, <span class="string">','</span>.join(self.papers))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person1 = Person(<span class="string">'Sachin'</span>)</span><br><span class="line">student1 = Student(<span class="string">'Kusha1'</span>, <span class="string">'CSE'</span>, <span class="number">2005</span>)</span><br><span class="line">teacher1 = Teacher(<span class="string">'Prasha1'</span>, [<span class="string">'c'</span>, <span class="string">'c++'</span>])</span><br><span class="line"></span><br><span class="line">print(person1.get_details())</span><br><span class="line">print(student1.get_details())</span><br><span class="line">print(teacher1.get_details())</span><br></pre></td></tr></table></figure><h3 id="属性读取方法"><a href="#属性读取方法" class="headerlink" title="属性读取方法"></a>属性读取方法</h3><p>在 Python 中请不要使用属性(attributes)读取方法(getters 和 setters)。如果之前接触过其他语言(如 Java)，你可能会在你的类里定义属性读取方法，请不要这样做，直接使用属性就可以了，看下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>std = Student(<span class="string">"Kushal Das"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(std.name)</span><br><span class="line">Kushal Das</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>std.name = <span class="string">"Python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(std.name)</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>如果你想要更精确的调整控制属性的权限，你可以使用 @property 装饰器，而@property 装饰器就是负责把一个方法变成属性调用的。看下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rate)</span>:</span></span><br><span class="line">        <span class="string">"""帐号类，amount 是美元金额"""</span></span><br><span class="line">        self.__amt = <span class="number">0</span></span><br><span class="line">        self.rate = rate</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""账户余额(美元)"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__amt</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cny</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""账户余额(人民币)"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__amt * self.rate</span><br><span class="line"></span><br><span class="line"><span class="meta">    @amount.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">amount</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"sorry,no negative amount in the account."</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.__amt = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 汇率</span></span><br><span class="line">    acc = Account(rate=<span class="number">6.63</span>)</span><br><span class="line">    acc.amount = <span class="number">20</span></span><br><span class="line">    print(<span class="string">"Dollar amount:"</span>, acc.amount)</span><br><span class="line">    print(<span class="string">"In CNY:"</span>, acc.cny)</span><br><span class="line">    acc.amount = <span class="number">-200</span></span><br><span class="line">    print(<span class="string">"Dollar amount:"</span>, acc.amount)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文章学习了 Python 继承、属性读取方法和装饰器，如果博友们看到有代码错误，请指出错处，我将不胜感激～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;似乎很久没有写博文了，那就进入主题吧，今天通过这篇文章来学习 Python 继承、属性读取方法和装饰器。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;当一个类继承另一个类
      
    
    </summary>
    
      <category term="Python" scheme="https://andchen.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://andchen.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>不同语言的妙处--冒泡</title>
    <link href="https://andchen.com/2018/05/28/different_languages/"/>
    <id>https://andchen.com/2018/05/28/different_languages/</id>
    <published>2018-05-28T13:04:17.000Z</published>
    <updated>2018-07-02T02:46:15.559Z</updated>
    
    <content type="html"><![CDATA[<p>最近，有位企业的老师给我们上课，课后布置了一个用 Java 实现冒泡排序的作业 ，然而，什么是冒泡排序呢？请看下面：</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序 (Bubble sort) 是一种最简单的交换排序算法。我猜，大概是所有程序员都会用到的算法吧。 </p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><h3 id="第一轮排序"><a href="#第一轮排序" class="headerlink" title="第一轮排序"></a>第一轮排序</h3><p>比较两个相邻元素，如果第一个比第二个大，则交换两个元素的值。</p><p>进行下两个元素的比较，即比较第二个和第三个元素，如果前者大于后者，则交换。</p><p>再进行下两个元素的比较。直到较第 n-1 和第 n 元素进行比较，如果前者大于后者，则交换。</p><p>可以知道，最后一个元素 n ，肯定是 n 个元素中最大的元素。</p><h3 id="第二轮排序"><a href="#第二轮排序" class="headerlink" title="第二轮排序"></a>第二轮排序</h3><p>重复执行第一轮执行的动作，直到第 n-2 个元素和第 n-1 个元素进行比较。如前者大于后者，则交换。</p><p>由于第一轮排序已经将最大元素放置到第 n 个位置，所以本次排序无考虑第 n 个元素。即第 n 个元素不参加本次排序。</p><p>……</p><h3 id="重复执行"><a href="#重复执行" class="headerlink" title="重复执行"></a>重复执行</h3><p>直到只剩一个元素，那么这个元素一定是最小元素，排序结束。显然，进行了 n-1 次排序。</p><p>上述过程，每轮排序都会有一个元素从某个位置慢慢“浮动”到最终所属的位置,就像气泡总会浮动到水的最顶端。在冒泡排序中，每一轮排序都会有一个元素(气泡)替换到本次排序的最后一个位置(水的最顶端)，注意，是本次排序的最后一个位置(第一轮，则为 n；第二轮，则为 n-1；第三轮，则为 n-2 ~~~ )。</p><h2 id="Java-代码实现"><a href="#Java-代码实现" class="headerlink" title="Java 代码实现"></a>Java 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">14</span>, <span class="number">4</span>, <span class="number">18</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">25</span>, &#125;;</span><br><span class="line">Num.num(arr,arr.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; l; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">t = a[j - <span class="number">1</span>];</span><br><span class="line">a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(li)</span>:</span></span><br><span class="line">    count = len(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> li[i] &gt; li[j]:</span><br><span class="line">                li[i], li[j] = li[j], li[i]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">    bubble(li)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure><h2 id="kotlin-代码实现"><a href="#kotlin-代码实现" class="headerlink" title="kotlin 代码实现"></a>kotlin 代码实现</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bubbleSort</span><span class="params">(array: <span class="type">IntArray</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//非法检查</span></span><br><span class="line"><span class="keyword">if</span> (array.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> size = array.size</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until size-i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (array[j<span class="number">-1</span>]&gt;array[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">val</span> temp=array[j<span class="number">-1</span>]</span><br><span class="line">array[j<span class="number">-1</span>]=array[j]</span><br><span class="line">array[j]=temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">val</span> sort= intArrayOf(<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">bubbleSort(sort)</span><br><span class="line">println(<span class="string">"数字从打到小排序得："</span>)</span><br><span class="line">sort.forEach &#123;</span><br><span class="line">print(<span class="string">"<span class="variable">$it</span>"</span>+<span class="string">"\t"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，把这篇文章送给每一位学习冒泡排序的程序员，希望可以帮助他们，也能学后写博文，进行把所学知识梳理成章。由于自己水平有限，或许文章可能会有纰漏，望各位批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，有位企业的老师给我们上课，课后布置了一个用 Java 实现冒泡排序的作业 ，然而，什么是冒泡排序呢？请看下面：&lt;/p&gt;
&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1
      
    
    </summary>
    
      <category term="Program" scheme="https://andchen.com/categories/Program/"/>
    
    
      <category term="Program" scheme="https://andchen.com/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>My_Life</title>
    <link href="https://andchen.com/2018/05/19/My_Life/"/>
    <id>https://andchen.com/2018/05/19/My_Life/</id>
    <published>2018-05-19T13:13:27.000Z</published>
    <updated>2018-05-19T15:26:09.711Z</updated>
    
    <content type="html"><![CDATA[<p>时间匆匆而过，刹那间，发现离考踏入英语四级的考场还有25天左右，平时淡定的我，忽然慌了起来。无论最后的结果如何，剩下的20多天都要埋头苦干，我相信 “ Where there is a will，there is a way. “</p><img src="/2018/05/19/My_Life/img.jpeg"><p>虽然这段时间可能很累，学的东西会很多，或者连打电话给家人的时间都没有，体重也往下降了，但是我相信有舍才有得。</p><p>我很感谢一个人，TA一直以来都在我身边陪着我，让我在学习中充满正能力，拥有无止境的动力。但我很惭愧有的时候我辜负他对我的期望，他却没有嫌弃我，在默默的支持我。今天是特别的一天，我想对你说辛苦了，520。</p><p>骚年，加油，趁着还年轻辛苦点也值得。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间匆匆而过，刹那间，发现离考踏入英语四级的考场还有25天左右，平时淡定的我，忽然慌了起来。无论最后的结果如何，剩下的20多天都要埋头苦干，我相信 “ Where there is a will，there is a way. “&lt;/p&gt;
&lt;img src=&quot;/2018/0
      
    
    </summary>
    
      <category term="Life" scheme="https://andchen.com/categories/Life/"/>
    
    
      <category term="Life" scheme="https://andchen.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>model 的继承</title>
    <link href="https://andchen.com/2018/05/14/Inheritance/"/>
    <id>https://andchen.com/2018/05/14/Inheritance/</id>
    <published>2018-05-14T11:54:03.000Z</published>
    <updated>2018-05-14T13:05:35.026Z</updated>
    
    <content type="html"><![CDATA[<p>作为小白的我，没学过 Django 中的 model 继承，今天学习后，我非常激动。我发现 Django 中的 model 继承和 Python 的类继承十分相似，不过基类要是 django.db.models.Model。</p><p>Django 中有三种继承关系：</p><h4 id="Abstract-base-classes"><a href="#Abstract-base-classes" class="headerlink" title="Abstract base classes"></a>Abstract base classes</h4><img src="/2018/05/14/Inheritance/img1.jpg"><p>这是用父 model 来保存那些你不想在子 model 中重复录入的信息。父类是不使用的也就是不生成单独的数据表，这种情况下使用抽象基类继承 Abstract base classes。</p><h4 id="Multi-table-inheritance"><a href="#Multi-table-inheritance" class="headerlink" title="Multi-table inheritance"></a>Multi-table inheritance</h4><img src="/2018/05/14/Inheritance/img2.jpg"><p>这是从现有的Model继承并让每个Model都有自己的数据表，那么使用多重表继承。</p><h4 id="Proxy-models"><a href="#Proxy-models" class="headerlink" title="Proxy models"></a>Proxy models</h4><p>楼上采用多重表继承的方式需要为每个类创建一张数据据表，比较消耗资源。为了减少这种不必要的消耗，可以采用代理模型，可以对代理模型进行数据操作，而反应在原始模型上。</p><img src="/2018/05/14/Inheritance/img3.jpg"><p>如果你只想在 model 中修改 Python-level 级的行为，而不涉及字段改变。 代理 model 适用于这种场合。而 proxy model 必须继承一个非抽象 model，proxy model 还可以继承一个 proxy model 共享一个非抽象 model。如果没有为 proxy 指定一个 manager 那么其将继承父类的 manager，如果定义了一个 manager，那么这个 manager 称谓 proxy model 的默认 manager。同时父类的 manager 照样能够运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为小白的我，没学过 Django 中的 model 继承，今天学习后，我非常激动。我发现 Django 中的 model 继承和 Python 的类继承十分相似，不过基类要是 django.db.models.Model。&lt;/p&gt;
&lt;p&gt;Django 中有三种继承关系：&lt;
      
    
    </summary>
    
      <category term="Django" scheme="https://andchen.com/categories/Django/"/>
    
    
      <category term="Django" scheme="https://andchen.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>对象和委托</title>
    <link href="https://andchen.com/2018/05/13/Object_Delegate/"/>
    <id>https://andchen.com/2018/05/13/Object_Delegate/</id>
    <published>2018-05-13T01:09:04.000Z</published>
    <updated>2018-05-13T03:54:29.679Z</updated>
    
    <content type="html"><![CDATA[<p>每当学习 Kotlin 的时候，我总想到 Java，它们之间的不同之处。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是 Kotlin 中的一个重要概念，可能很多读者会有疑问：什么是对象？对象是实例化类后的东西？为什么要提供对象呢？要回答这些问题，还要从 Java 说起。</p><p>在 Java 中，有一个匿名类的概念，也就是在创建类时，无须指定类的名字，匿名类一般用于方法的参数类型。基本概念是方法参数需要接收一个类或者接口的实例，而这个实例只是在该方法中临时用一下，并没有必要单独定义一个类，或单独创建一个对象变量。因此，就在传入方法参数值的同时创建了类的实例。看！下面的 Java 中匿名类的使用：</p><img src="/2018/05/13/Object_Delegate/img1.jpg"><p>在 Kotlin 中，也有类似的功能，但不是匿名类，而是对象。例如，下面的 Kotlin 代码完全实现了前面 Java代码的功能。要建立一个对象，需要使用 object 关键字，该对象要继承的类需要与 object 之间用冒号(:)分隔：如 MyClass(“Tom”)。</p><img src="/2018/05/13/Object_Delegate/img2.jpg"><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托其实是一种非常好的代码重用方式，有点类似 AOP (面向方面编程)，也就是将多个地方出现的代码放到同一个地方，以便被多个类属性重用。在学 kotlin 委托时，让我最深刻的就是委托属性和委托类的初始化函数。</p><h4 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h4><p>在实际应用中，很多类属性的 getter 和 setter 函数的代码相同或相似，当然，从技术上来说，在每个类中编写相同的代码是可行的，但这样就会造成代码的大量冗余，而且维护困难。为了解决这个问题，Kotlin 允许属性委托，也就是将属性的 getter 和 setter 函数代码放在一个我委托类中，如果在类中声明属性，只需要指定属性类。这样就可以大大减少代码的冗余也让代码更容易维护。</p><h4 id="委托类的初始化函数"><a href="#委托类的初始化函数" class="headerlink" title="委托类的初始化函数"></a>委托类的初始化函数</h4><p>在学习委托类的初始化函数的时候，让我最难理解的就是下面那句代码。</p><img src="/2018/05/13/Object_Delegate/image.png"><p>这句代码让我很困惑，特别是 Any 和 Any？，到底这两个有什么区别呢？然后我就去 Google，最后很开心，我找到了，也懂了。</p><p>原来，Kotlin 里的 Any，它相当于 Java 里的 Object，所有其他的类都默认继承了它。而Any 是非空类型层级结构的顶层，Any? 则是可空类型层级结构的顶层。因为 Any? 是 Any 的父类型，所以 Any? 是 Kotlin 类型层级结构的最顶端。例如： String 是 Any 的子类型，则 String? 是 Any? 的子类型。</p><p>而且，kotlin.Any是没有声明超类的类的默认超类。任何不是java.lang.Object，特别是它没有除equals（），hashCode（）和toString（）方法以外的任何成员。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>对象和委托是 Kotlin 中两个比较大的语法糖，对象相当于 Java 中的匿名对象，而委托的主要作用是实现代码重用，有点类似 AOP (面向方面编程)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每当学习 Kotlin 的时候，我总想到 Java，它们之间的不同之处。&lt;/p&gt;
&lt;h3 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h3&gt;&lt;p&gt;对象是 Kotlin 中的一个重要概念，可能很多读者
      
    
    </summary>
    
      <category term="Kotlin" scheme="https://andchen.com/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="https://andchen.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
